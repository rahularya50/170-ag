// Code generated by entc, DO NOT EDIT.

package generated

import (
	"170-ag/ent/generated/codingdraft"
	"170-ag/ent/generated/codingextension"
	"170-ag/ent/generated/codingproblem"
	"170-ag/ent/generated/codingsubmission"
	"170-ag/ent/generated/codingsubmissionstaffdata"
	"170-ag/ent/generated/codingtestcase"
	"170-ag/ent/generated/codingtestcasedata"
	"170-ag/ent/generated/predicate"
	"170-ag/ent/generated/projectscore"
	"170-ag/ent/generated/projectteam"
	"170-ag/ent/generated/user"
	"170-ag/ent/models"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCodingDraft               = "CodingDraft"
	TypeCodingExtension           = "CodingExtension"
	TypeCodingProblem             = "CodingProblem"
	TypeCodingSubmission          = "CodingSubmission"
	TypeCodingSubmissionStaffData = "CodingSubmissionStaffData"
	TypeCodingTestCase            = "CodingTestCase"
	TypeCodingTestCaseData        = "CodingTestCaseData"
	TypeProjectScore              = "ProjectScore"
	TypeProjectTeam               = "ProjectTeam"
	TypeUser                      = "User"
)

// CodingDraftMutation represents an operation that mutates the CodingDraft nodes in the graph.
type CodingDraftMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	create_time           *time.Time
	update_time           *time.Time
	code                  *string
	clearedFields         map[string]struct{}
	author                *int
	clearedauthor         bool
	coding_problem        *int
	clearedcoding_problem bool
	done                  bool
	oldValue              func(context.Context) (*CodingDraft, error)
	predicates            []predicate.CodingDraft
}

var _ ent.Mutation = (*CodingDraftMutation)(nil)

// codingdraftOption allows management of the mutation configuration using functional options.
type codingdraftOption func(*CodingDraftMutation)

// newCodingDraftMutation creates new mutation for the CodingDraft entity.
func newCodingDraftMutation(c config, op Op, opts ...codingdraftOption) *CodingDraftMutation {
	m := &CodingDraftMutation{
		config:        c,
		op:            op,
		typ:           TypeCodingDraft,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCodingDraftID sets the ID field of the mutation.
func withCodingDraftID(id int) codingdraftOption {
	return func(m *CodingDraftMutation) {
		var (
			err   error
			once  sync.Once
			value *CodingDraft
		)
		m.oldValue = func(ctx context.Context) (*CodingDraft, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CodingDraft.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCodingDraft sets the old CodingDraft of the mutation.
func withCodingDraft(node *CodingDraft) codingdraftOption {
	return func(m *CodingDraftMutation) {
		m.oldValue = func(context.Context) (*CodingDraft, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CodingDraftMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CodingDraftMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CodingDraftMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CodingDraftMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CodingDraft.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *CodingDraftMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CodingDraftMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the CodingDraft entity.
// If the CodingDraft object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingDraftMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CodingDraftMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CodingDraftMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CodingDraftMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the CodingDraft entity.
// If the CodingDraft object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingDraftMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CodingDraftMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetCode sets the "code" field.
func (m *CodingDraftMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *CodingDraftMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the CodingDraft entity.
// If the CodingDraft object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingDraftMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *CodingDraftMutation) ResetCode() {
	m.code = nil
}

// SetAuthorID sets the "author" edge to the User entity by id.
func (m *CodingDraftMutation) SetAuthorID(id int) {
	m.author = &id
}

// ClearAuthor clears the "author" edge to the User entity.
func (m *CodingDraftMutation) ClearAuthor() {
	m.clearedauthor = true
}

// AuthorCleared reports if the "author" edge to the User entity was cleared.
func (m *CodingDraftMutation) AuthorCleared() bool {
	return m.clearedauthor
}

// AuthorID returns the "author" edge ID in the mutation.
func (m *CodingDraftMutation) AuthorID() (id int, exists bool) {
	if m.author != nil {
		return *m.author, true
	}
	return
}

// AuthorIDs returns the "author" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthorID instead. It exists only for internal usage by the builders.
func (m *CodingDraftMutation) AuthorIDs() (ids []int) {
	if id := m.author; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthor resets all changes to the "author" edge.
func (m *CodingDraftMutation) ResetAuthor() {
	m.author = nil
	m.clearedauthor = false
}

// SetCodingProblemID sets the "coding_problem" edge to the CodingProblem entity by id.
func (m *CodingDraftMutation) SetCodingProblemID(id int) {
	m.coding_problem = &id
}

// ClearCodingProblem clears the "coding_problem" edge to the CodingProblem entity.
func (m *CodingDraftMutation) ClearCodingProblem() {
	m.clearedcoding_problem = true
}

// CodingProblemCleared reports if the "coding_problem" edge to the CodingProblem entity was cleared.
func (m *CodingDraftMutation) CodingProblemCleared() bool {
	return m.clearedcoding_problem
}

// CodingProblemID returns the "coding_problem" edge ID in the mutation.
func (m *CodingDraftMutation) CodingProblemID() (id int, exists bool) {
	if m.coding_problem != nil {
		return *m.coding_problem, true
	}
	return
}

// CodingProblemIDs returns the "coding_problem" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CodingProblemID instead. It exists only for internal usage by the builders.
func (m *CodingDraftMutation) CodingProblemIDs() (ids []int) {
	if id := m.coding_problem; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCodingProblem resets all changes to the "coding_problem" edge.
func (m *CodingDraftMutation) ResetCodingProblem() {
	m.coding_problem = nil
	m.clearedcoding_problem = false
}

// Where appends a list predicates to the CodingDraftMutation builder.
func (m *CodingDraftMutation) Where(ps ...predicate.CodingDraft) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CodingDraftMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CodingDraft).
func (m *CodingDraftMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CodingDraftMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, codingdraft.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, codingdraft.FieldUpdateTime)
	}
	if m.code != nil {
		fields = append(fields, codingdraft.FieldCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CodingDraftMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case codingdraft.FieldCreateTime:
		return m.CreateTime()
	case codingdraft.FieldUpdateTime:
		return m.UpdateTime()
	case codingdraft.FieldCode:
		return m.Code()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CodingDraftMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case codingdraft.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case codingdraft.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case codingdraft.FieldCode:
		return m.OldCode(ctx)
	}
	return nil, fmt.Errorf("unknown CodingDraft field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CodingDraftMutation) SetField(name string, value ent.Value) error {
	switch name {
	case codingdraft.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case codingdraft.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case codingdraft.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	}
	return fmt.Errorf("unknown CodingDraft field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CodingDraftMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CodingDraftMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CodingDraftMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CodingDraft numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CodingDraftMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CodingDraftMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CodingDraftMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CodingDraft nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CodingDraftMutation) ResetField(name string) error {
	switch name {
	case codingdraft.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case codingdraft.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case codingdraft.FieldCode:
		m.ResetCode()
		return nil
	}
	return fmt.Errorf("unknown CodingDraft field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CodingDraftMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.author != nil {
		edges = append(edges, codingdraft.EdgeAuthor)
	}
	if m.coding_problem != nil {
		edges = append(edges, codingdraft.EdgeCodingProblem)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CodingDraftMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case codingdraft.EdgeAuthor:
		if id := m.author; id != nil {
			return []ent.Value{*id}
		}
	case codingdraft.EdgeCodingProblem:
		if id := m.coding_problem; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CodingDraftMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CodingDraftMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CodingDraftMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedauthor {
		edges = append(edges, codingdraft.EdgeAuthor)
	}
	if m.clearedcoding_problem {
		edges = append(edges, codingdraft.EdgeCodingProblem)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CodingDraftMutation) EdgeCleared(name string) bool {
	switch name {
	case codingdraft.EdgeAuthor:
		return m.clearedauthor
	case codingdraft.EdgeCodingProblem:
		return m.clearedcoding_problem
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CodingDraftMutation) ClearEdge(name string) error {
	switch name {
	case codingdraft.EdgeAuthor:
		m.ClearAuthor()
		return nil
	case codingdraft.EdgeCodingProblem:
		m.ClearCodingProblem()
		return nil
	}
	return fmt.Errorf("unknown CodingDraft unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CodingDraftMutation) ResetEdge(name string) error {
	switch name {
	case codingdraft.EdgeAuthor:
		m.ResetAuthor()
		return nil
	case codingdraft.EdgeCodingProblem:
		m.ResetCodingProblem()
		return nil
	}
	return fmt.Errorf("unknown CodingDraft edge %s", name)
}

// CodingExtensionMutation represents an operation that mutates the CodingExtension nodes in the graph.
type CodingExtensionMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	create_time           *time.Time
	update_time           *time.Time
	deadline              *time.Time
	clearedFields         map[string]struct{}
	student               *int
	clearedstudent        bool
	coding_problem        *int
	clearedcoding_problem bool
	done                  bool
	oldValue              func(context.Context) (*CodingExtension, error)
	predicates            []predicate.CodingExtension
}

var _ ent.Mutation = (*CodingExtensionMutation)(nil)

// codingextensionOption allows management of the mutation configuration using functional options.
type codingextensionOption func(*CodingExtensionMutation)

// newCodingExtensionMutation creates new mutation for the CodingExtension entity.
func newCodingExtensionMutation(c config, op Op, opts ...codingextensionOption) *CodingExtensionMutation {
	m := &CodingExtensionMutation{
		config:        c,
		op:            op,
		typ:           TypeCodingExtension,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCodingExtensionID sets the ID field of the mutation.
func withCodingExtensionID(id int) codingextensionOption {
	return func(m *CodingExtensionMutation) {
		var (
			err   error
			once  sync.Once
			value *CodingExtension
		)
		m.oldValue = func(ctx context.Context) (*CodingExtension, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CodingExtension.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCodingExtension sets the old CodingExtension of the mutation.
func withCodingExtension(node *CodingExtension) codingextensionOption {
	return func(m *CodingExtensionMutation) {
		m.oldValue = func(context.Context) (*CodingExtension, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CodingExtensionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CodingExtensionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CodingExtensionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CodingExtensionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CodingExtension.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *CodingExtensionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CodingExtensionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the CodingExtension entity.
// If the CodingExtension object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingExtensionMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CodingExtensionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CodingExtensionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CodingExtensionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the CodingExtension entity.
// If the CodingExtension object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingExtensionMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CodingExtensionMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeadline sets the "deadline" field.
func (m *CodingExtensionMutation) SetDeadline(t time.Time) {
	m.deadline = &t
}

// Deadline returns the value of the "deadline" field in the mutation.
func (m *CodingExtensionMutation) Deadline() (r time.Time, exists bool) {
	v := m.deadline
	if v == nil {
		return
	}
	return *v, true
}

// OldDeadline returns the old "deadline" field's value of the CodingExtension entity.
// If the CodingExtension object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingExtensionMutation) OldDeadline(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeadline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeadline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeadline: %w", err)
	}
	return oldValue.Deadline, nil
}

// ResetDeadline resets all changes to the "deadline" field.
func (m *CodingExtensionMutation) ResetDeadline() {
	m.deadline = nil
}

// SetStudentID sets the "student" edge to the User entity by id.
func (m *CodingExtensionMutation) SetStudentID(id int) {
	m.student = &id
}

// ClearStudent clears the "student" edge to the User entity.
func (m *CodingExtensionMutation) ClearStudent() {
	m.clearedstudent = true
}

// StudentCleared reports if the "student" edge to the User entity was cleared.
func (m *CodingExtensionMutation) StudentCleared() bool {
	return m.clearedstudent
}

// StudentID returns the "student" edge ID in the mutation.
func (m *CodingExtensionMutation) StudentID() (id int, exists bool) {
	if m.student != nil {
		return *m.student, true
	}
	return
}

// StudentIDs returns the "student" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StudentID instead. It exists only for internal usage by the builders.
func (m *CodingExtensionMutation) StudentIDs() (ids []int) {
	if id := m.student; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStudent resets all changes to the "student" edge.
func (m *CodingExtensionMutation) ResetStudent() {
	m.student = nil
	m.clearedstudent = false
}

// SetCodingProblemID sets the "coding_problem" edge to the CodingProblem entity by id.
func (m *CodingExtensionMutation) SetCodingProblemID(id int) {
	m.coding_problem = &id
}

// ClearCodingProblem clears the "coding_problem" edge to the CodingProblem entity.
func (m *CodingExtensionMutation) ClearCodingProblem() {
	m.clearedcoding_problem = true
}

// CodingProblemCleared reports if the "coding_problem" edge to the CodingProblem entity was cleared.
func (m *CodingExtensionMutation) CodingProblemCleared() bool {
	return m.clearedcoding_problem
}

// CodingProblemID returns the "coding_problem" edge ID in the mutation.
func (m *CodingExtensionMutation) CodingProblemID() (id int, exists bool) {
	if m.coding_problem != nil {
		return *m.coding_problem, true
	}
	return
}

// CodingProblemIDs returns the "coding_problem" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CodingProblemID instead. It exists only for internal usage by the builders.
func (m *CodingExtensionMutation) CodingProblemIDs() (ids []int) {
	if id := m.coding_problem; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCodingProblem resets all changes to the "coding_problem" edge.
func (m *CodingExtensionMutation) ResetCodingProblem() {
	m.coding_problem = nil
	m.clearedcoding_problem = false
}

// Where appends a list predicates to the CodingExtensionMutation builder.
func (m *CodingExtensionMutation) Where(ps ...predicate.CodingExtension) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CodingExtensionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CodingExtension).
func (m *CodingExtensionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CodingExtensionMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, codingextension.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, codingextension.FieldUpdateTime)
	}
	if m.deadline != nil {
		fields = append(fields, codingextension.FieldDeadline)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CodingExtensionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case codingextension.FieldCreateTime:
		return m.CreateTime()
	case codingextension.FieldUpdateTime:
		return m.UpdateTime()
	case codingextension.FieldDeadline:
		return m.Deadline()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CodingExtensionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case codingextension.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case codingextension.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case codingextension.FieldDeadline:
		return m.OldDeadline(ctx)
	}
	return nil, fmt.Errorf("unknown CodingExtension field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CodingExtensionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case codingextension.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case codingextension.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case codingextension.FieldDeadline:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeadline(v)
		return nil
	}
	return fmt.Errorf("unknown CodingExtension field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CodingExtensionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CodingExtensionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CodingExtensionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CodingExtension numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CodingExtensionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CodingExtensionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CodingExtensionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CodingExtension nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CodingExtensionMutation) ResetField(name string) error {
	switch name {
	case codingextension.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case codingextension.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case codingextension.FieldDeadline:
		m.ResetDeadline()
		return nil
	}
	return fmt.Errorf("unknown CodingExtension field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CodingExtensionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.student != nil {
		edges = append(edges, codingextension.EdgeStudent)
	}
	if m.coding_problem != nil {
		edges = append(edges, codingextension.EdgeCodingProblem)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CodingExtensionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case codingextension.EdgeStudent:
		if id := m.student; id != nil {
			return []ent.Value{*id}
		}
	case codingextension.EdgeCodingProblem:
		if id := m.coding_problem; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CodingExtensionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CodingExtensionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CodingExtensionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedstudent {
		edges = append(edges, codingextension.EdgeStudent)
	}
	if m.clearedcoding_problem {
		edges = append(edges, codingextension.EdgeCodingProblem)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CodingExtensionMutation) EdgeCleared(name string) bool {
	switch name {
	case codingextension.EdgeStudent:
		return m.clearedstudent
	case codingextension.EdgeCodingProblem:
		return m.clearedcoding_problem
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CodingExtensionMutation) ClearEdge(name string) error {
	switch name {
	case codingextension.EdgeStudent:
		m.ClearStudent()
		return nil
	case codingextension.EdgeCodingProblem:
		m.ClearCodingProblem()
		return nil
	}
	return fmt.Errorf("unknown CodingExtension unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CodingExtensionMutation) ResetEdge(name string) error {
	switch name {
	case codingextension.EdgeStudent:
		m.ResetStudent()
		return nil
	case codingextension.EdgeCodingProblem:
		m.ResetCodingProblem()
		return nil
	}
	return fmt.Errorf("unknown CodingExtension edge %s", name)
}

// CodingProblemMutation represents an operation that mutates the CodingProblem nodes in the graph.
type CodingProblemMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	create_time        *time.Time
	update_time        *time.Time
	name               *string
	statement          *string
	skeleton           *string
	released           *bool
	deadline           *time.Time
	clearedFields      map[string]struct{}
	drafts             map[int]struct{}
	removeddrafts      map[int]struct{}
	cleareddrafts      bool
	test_cases         map[int]struct{}
	removedtest_cases  map[int]struct{}
	clearedtest_cases  bool
	submissions        map[int]struct{}
	removedsubmissions map[int]struct{}
	clearedsubmissions bool
	extensions         map[int]struct{}
	removedextensions  map[int]struct{}
	clearedextensions  bool
	done               bool
	oldValue           func(context.Context) (*CodingProblem, error)
	predicates         []predicate.CodingProblem
}

var _ ent.Mutation = (*CodingProblemMutation)(nil)

// codingproblemOption allows management of the mutation configuration using functional options.
type codingproblemOption func(*CodingProblemMutation)

// newCodingProblemMutation creates new mutation for the CodingProblem entity.
func newCodingProblemMutation(c config, op Op, opts ...codingproblemOption) *CodingProblemMutation {
	m := &CodingProblemMutation{
		config:        c,
		op:            op,
		typ:           TypeCodingProblem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCodingProblemID sets the ID field of the mutation.
func withCodingProblemID(id int) codingproblemOption {
	return func(m *CodingProblemMutation) {
		var (
			err   error
			once  sync.Once
			value *CodingProblem
		)
		m.oldValue = func(ctx context.Context) (*CodingProblem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CodingProblem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCodingProblem sets the old CodingProblem of the mutation.
func withCodingProblem(node *CodingProblem) codingproblemOption {
	return func(m *CodingProblemMutation) {
		m.oldValue = func(context.Context) (*CodingProblem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CodingProblemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CodingProblemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CodingProblemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CodingProblemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CodingProblem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *CodingProblemMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CodingProblemMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the CodingProblem entity.
// If the CodingProblem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingProblemMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CodingProblemMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CodingProblemMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CodingProblemMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the CodingProblem entity.
// If the CodingProblem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingProblemMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CodingProblemMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *CodingProblemMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CodingProblemMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CodingProblem entity.
// If the CodingProblem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingProblemMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CodingProblemMutation) ResetName() {
	m.name = nil
}

// SetStatement sets the "statement" field.
func (m *CodingProblemMutation) SetStatement(s string) {
	m.statement = &s
}

// Statement returns the value of the "statement" field in the mutation.
func (m *CodingProblemMutation) Statement() (r string, exists bool) {
	v := m.statement
	if v == nil {
		return
	}
	return *v, true
}

// OldStatement returns the old "statement" field's value of the CodingProblem entity.
// If the CodingProblem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingProblemMutation) OldStatement(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatement is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatement requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatement: %w", err)
	}
	return oldValue.Statement, nil
}

// ResetStatement resets all changes to the "statement" field.
func (m *CodingProblemMutation) ResetStatement() {
	m.statement = nil
}

// SetSkeleton sets the "skeleton" field.
func (m *CodingProblemMutation) SetSkeleton(s string) {
	m.skeleton = &s
}

// Skeleton returns the value of the "skeleton" field in the mutation.
func (m *CodingProblemMutation) Skeleton() (r string, exists bool) {
	v := m.skeleton
	if v == nil {
		return
	}
	return *v, true
}

// OldSkeleton returns the old "skeleton" field's value of the CodingProblem entity.
// If the CodingProblem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingProblemMutation) OldSkeleton(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkeleton is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkeleton requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkeleton: %w", err)
	}
	return oldValue.Skeleton, nil
}

// ResetSkeleton resets all changes to the "skeleton" field.
func (m *CodingProblemMutation) ResetSkeleton() {
	m.skeleton = nil
}

// SetReleased sets the "released" field.
func (m *CodingProblemMutation) SetReleased(b bool) {
	m.released = &b
}

// Released returns the value of the "released" field in the mutation.
func (m *CodingProblemMutation) Released() (r bool, exists bool) {
	v := m.released
	if v == nil {
		return
	}
	return *v, true
}

// OldReleased returns the old "released" field's value of the CodingProblem entity.
// If the CodingProblem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingProblemMutation) OldReleased(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReleased is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReleased requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReleased: %w", err)
	}
	return oldValue.Released, nil
}

// ResetReleased resets all changes to the "released" field.
func (m *CodingProblemMutation) ResetReleased() {
	m.released = nil
}

// SetDeadline sets the "deadline" field.
func (m *CodingProblemMutation) SetDeadline(t time.Time) {
	m.deadline = &t
}

// Deadline returns the value of the "deadline" field in the mutation.
func (m *CodingProblemMutation) Deadline() (r time.Time, exists bool) {
	v := m.deadline
	if v == nil {
		return
	}
	return *v, true
}

// OldDeadline returns the old "deadline" field's value of the CodingProblem entity.
// If the CodingProblem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingProblemMutation) OldDeadline(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeadline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeadline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeadline: %w", err)
	}
	return oldValue.Deadline, nil
}

// ResetDeadline resets all changes to the "deadline" field.
func (m *CodingProblemMutation) ResetDeadline() {
	m.deadline = nil
}

// AddDraftIDs adds the "drafts" edge to the CodingDraft entity by ids.
func (m *CodingProblemMutation) AddDraftIDs(ids ...int) {
	if m.drafts == nil {
		m.drafts = make(map[int]struct{})
	}
	for i := range ids {
		m.drafts[ids[i]] = struct{}{}
	}
}

// ClearDrafts clears the "drafts" edge to the CodingDraft entity.
func (m *CodingProblemMutation) ClearDrafts() {
	m.cleareddrafts = true
}

// DraftsCleared reports if the "drafts" edge to the CodingDraft entity was cleared.
func (m *CodingProblemMutation) DraftsCleared() bool {
	return m.cleareddrafts
}

// RemoveDraftIDs removes the "drafts" edge to the CodingDraft entity by IDs.
func (m *CodingProblemMutation) RemoveDraftIDs(ids ...int) {
	if m.removeddrafts == nil {
		m.removeddrafts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.drafts, ids[i])
		m.removeddrafts[ids[i]] = struct{}{}
	}
}

// RemovedDrafts returns the removed IDs of the "drafts" edge to the CodingDraft entity.
func (m *CodingProblemMutation) RemovedDraftsIDs() (ids []int) {
	for id := range m.removeddrafts {
		ids = append(ids, id)
	}
	return
}

// DraftsIDs returns the "drafts" edge IDs in the mutation.
func (m *CodingProblemMutation) DraftsIDs() (ids []int) {
	for id := range m.drafts {
		ids = append(ids, id)
	}
	return
}

// ResetDrafts resets all changes to the "drafts" edge.
func (m *CodingProblemMutation) ResetDrafts() {
	m.drafts = nil
	m.cleareddrafts = false
	m.removeddrafts = nil
}

// AddTestCaseIDs adds the "test_cases" edge to the CodingTestCase entity by ids.
func (m *CodingProblemMutation) AddTestCaseIDs(ids ...int) {
	if m.test_cases == nil {
		m.test_cases = make(map[int]struct{})
	}
	for i := range ids {
		m.test_cases[ids[i]] = struct{}{}
	}
}

// ClearTestCases clears the "test_cases" edge to the CodingTestCase entity.
func (m *CodingProblemMutation) ClearTestCases() {
	m.clearedtest_cases = true
}

// TestCasesCleared reports if the "test_cases" edge to the CodingTestCase entity was cleared.
func (m *CodingProblemMutation) TestCasesCleared() bool {
	return m.clearedtest_cases
}

// RemoveTestCaseIDs removes the "test_cases" edge to the CodingTestCase entity by IDs.
func (m *CodingProblemMutation) RemoveTestCaseIDs(ids ...int) {
	if m.removedtest_cases == nil {
		m.removedtest_cases = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.test_cases, ids[i])
		m.removedtest_cases[ids[i]] = struct{}{}
	}
}

// RemovedTestCases returns the removed IDs of the "test_cases" edge to the CodingTestCase entity.
func (m *CodingProblemMutation) RemovedTestCasesIDs() (ids []int) {
	for id := range m.removedtest_cases {
		ids = append(ids, id)
	}
	return
}

// TestCasesIDs returns the "test_cases" edge IDs in the mutation.
func (m *CodingProblemMutation) TestCasesIDs() (ids []int) {
	for id := range m.test_cases {
		ids = append(ids, id)
	}
	return
}

// ResetTestCases resets all changes to the "test_cases" edge.
func (m *CodingProblemMutation) ResetTestCases() {
	m.test_cases = nil
	m.clearedtest_cases = false
	m.removedtest_cases = nil
}

// AddSubmissionIDs adds the "submissions" edge to the CodingSubmission entity by ids.
func (m *CodingProblemMutation) AddSubmissionIDs(ids ...int) {
	if m.submissions == nil {
		m.submissions = make(map[int]struct{})
	}
	for i := range ids {
		m.submissions[ids[i]] = struct{}{}
	}
}

// ClearSubmissions clears the "submissions" edge to the CodingSubmission entity.
func (m *CodingProblemMutation) ClearSubmissions() {
	m.clearedsubmissions = true
}

// SubmissionsCleared reports if the "submissions" edge to the CodingSubmission entity was cleared.
func (m *CodingProblemMutation) SubmissionsCleared() bool {
	return m.clearedsubmissions
}

// RemoveSubmissionIDs removes the "submissions" edge to the CodingSubmission entity by IDs.
func (m *CodingProblemMutation) RemoveSubmissionIDs(ids ...int) {
	if m.removedsubmissions == nil {
		m.removedsubmissions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.submissions, ids[i])
		m.removedsubmissions[ids[i]] = struct{}{}
	}
}

// RemovedSubmissions returns the removed IDs of the "submissions" edge to the CodingSubmission entity.
func (m *CodingProblemMutation) RemovedSubmissionsIDs() (ids []int) {
	for id := range m.removedsubmissions {
		ids = append(ids, id)
	}
	return
}

// SubmissionsIDs returns the "submissions" edge IDs in the mutation.
func (m *CodingProblemMutation) SubmissionsIDs() (ids []int) {
	for id := range m.submissions {
		ids = append(ids, id)
	}
	return
}

// ResetSubmissions resets all changes to the "submissions" edge.
func (m *CodingProblemMutation) ResetSubmissions() {
	m.submissions = nil
	m.clearedsubmissions = false
	m.removedsubmissions = nil
}

// AddExtensionIDs adds the "extensions" edge to the CodingExtension entity by ids.
func (m *CodingProblemMutation) AddExtensionIDs(ids ...int) {
	if m.extensions == nil {
		m.extensions = make(map[int]struct{})
	}
	for i := range ids {
		m.extensions[ids[i]] = struct{}{}
	}
}

// ClearExtensions clears the "extensions" edge to the CodingExtension entity.
func (m *CodingProblemMutation) ClearExtensions() {
	m.clearedextensions = true
}

// ExtensionsCleared reports if the "extensions" edge to the CodingExtension entity was cleared.
func (m *CodingProblemMutation) ExtensionsCleared() bool {
	return m.clearedextensions
}

// RemoveExtensionIDs removes the "extensions" edge to the CodingExtension entity by IDs.
func (m *CodingProblemMutation) RemoveExtensionIDs(ids ...int) {
	if m.removedextensions == nil {
		m.removedextensions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.extensions, ids[i])
		m.removedextensions[ids[i]] = struct{}{}
	}
}

// RemovedExtensions returns the removed IDs of the "extensions" edge to the CodingExtension entity.
func (m *CodingProblemMutation) RemovedExtensionsIDs() (ids []int) {
	for id := range m.removedextensions {
		ids = append(ids, id)
	}
	return
}

// ExtensionsIDs returns the "extensions" edge IDs in the mutation.
func (m *CodingProblemMutation) ExtensionsIDs() (ids []int) {
	for id := range m.extensions {
		ids = append(ids, id)
	}
	return
}

// ResetExtensions resets all changes to the "extensions" edge.
func (m *CodingProblemMutation) ResetExtensions() {
	m.extensions = nil
	m.clearedextensions = false
	m.removedextensions = nil
}

// Where appends a list predicates to the CodingProblemMutation builder.
func (m *CodingProblemMutation) Where(ps ...predicate.CodingProblem) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CodingProblemMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CodingProblem).
func (m *CodingProblemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CodingProblemMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, codingproblem.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, codingproblem.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, codingproblem.FieldName)
	}
	if m.statement != nil {
		fields = append(fields, codingproblem.FieldStatement)
	}
	if m.skeleton != nil {
		fields = append(fields, codingproblem.FieldSkeleton)
	}
	if m.released != nil {
		fields = append(fields, codingproblem.FieldReleased)
	}
	if m.deadline != nil {
		fields = append(fields, codingproblem.FieldDeadline)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CodingProblemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case codingproblem.FieldCreateTime:
		return m.CreateTime()
	case codingproblem.FieldUpdateTime:
		return m.UpdateTime()
	case codingproblem.FieldName:
		return m.Name()
	case codingproblem.FieldStatement:
		return m.Statement()
	case codingproblem.FieldSkeleton:
		return m.Skeleton()
	case codingproblem.FieldReleased:
		return m.Released()
	case codingproblem.FieldDeadline:
		return m.Deadline()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CodingProblemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case codingproblem.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case codingproblem.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case codingproblem.FieldName:
		return m.OldName(ctx)
	case codingproblem.FieldStatement:
		return m.OldStatement(ctx)
	case codingproblem.FieldSkeleton:
		return m.OldSkeleton(ctx)
	case codingproblem.FieldReleased:
		return m.OldReleased(ctx)
	case codingproblem.FieldDeadline:
		return m.OldDeadline(ctx)
	}
	return nil, fmt.Errorf("unknown CodingProblem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CodingProblemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case codingproblem.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case codingproblem.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case codingproblem.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case codingproblem.FieldStatement:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatement(v)
		return nil
	case codingproblem.FieldSkeleton:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkeleton(v)
		return nil
	case codingproblem.FieldReleased:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReleased(v)
		return nil
	case codingproblem.FieldDeadline:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeadline(v)
		return nil
	}
	return fmt.Errorf("unknown CodingProblem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CodingProblemMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CodingProblemMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CodingProblemMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CodingProblem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CodingProblemMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CodingProblemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CodingProblemMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CodingProblem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CodingProblemMutation) ResetField(name string) error {
	switch name {
	case codingproblem.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case codingproblem.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case codingproblem.FieldName:
		m.ResetName()
		return nil
	case codingproblem.FieldStatement:
		m.ResetStatement()
		return nil
	case codingproblem.FieldSkeleton:
		m.ResetSkeleton()
		return nil
	case codingproblem.FieldReleased:
		m.ResetReleased()
		return nil
	case codingproblem.FieldDeadline:
		m.ResetDeadline()
		return nil
	}
	return fmt.Errorf("unknown CodingProblem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CodingProblemMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.drafts != nil {
		edges = append(edges, codingproblem.EdgeDrafts)
	}
	if m.test_cases != nil {
		edges = append(edges, codingproblem.EdgeTestCases)
	}
	if m.submissions != nil {
		edges = append(edges, codingproblem.EdgeSubmissions)
	}
	if m.extensions != nil {
		edges = append(edges, codingproblem.EdgeExtensions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CodingProblemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case codingproblem.EdgeDrafts:
		ids := make([]ent.Value, 0, len(m.drafts))
		for id := range m.drafts {
			ids = append(ids, id)
		}
		return ids
	case codingproblem.EdgeTestCases:
		ids := make([]ent.Value, 0, len(m.test_cases))
		for id := range m.test_cases {
			ids = append(ids, id)
		}
		return ids
	case codingproblem.EdgeSubmissions:
		ids := make([]ent.Value, 0, len(m.submissions))
		for id := range m.submissions {
			ids = append(ids, id)
		}
		return ids
	case codingproblem.EdgeExtensions:
		ids := make([]ent.Value, 0, len(m.extensions))
		for id := range m.extensions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CodingProblemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removeddrafts != nil {
		edges = append(edges, codingproblem.EdgeDrafts)
	}
	if m.removedtest_cases != nil {
		edges = append(edges, codingproblem.EdgeTestCases)
	}
	if m.removedsubmissions != nil {
		edges = append(edges, codingproblem.EdgeSubmissions)
	}
	if m.removedextensions != nil {
		edges = append(edges, codingproblem.EdgeExtensions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CodingProblemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case codingproblem.EdgeDrafts:
		ids := make([]ent.Value, 0, len(m.removeddrafts))
		for id := range m.removeddrafts {
			ids = append(ids, id)
		}
		return ids
	case codingproblem.EdgeTestCases:
		ids := make([]ent.Value, 0, len(m.removedtest_cases))
		for id := range m.removedtest_cases {
			ids = append(ids, id)
		}
		return ids
	case codingproblem.EdgeSubmissions:
		ids := make([]ent.Value, 0, len(m.removedsubmissions))
		for id := range m.removedsubmissions {
			ids = append(ids, id)
		}
		return ids
	case codingproblem.EdgeExtensions:
		ids := make([]ent.Value, 0, len(m.removedextensions))
		for id := range m.removedextensions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CodingProblemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareddrafts {
		edges = append(edges, codingproblem.EdgeDrafts)
	}
	if m.clearedtest_cases {
		edges = append(edges, codingproblem.EdgeTestCases)
	}
	if m.clearedsubmissions {
		edges = append(edges, codingproblem.EdgeSubmissions)
	}
	if m.clearedextensions {
		edges = append(edges, codingproblem.EdgeExtensions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CodingProblemMutation) EdgeCleared(name string) bool {
	switch name {
	case codingproblem.EdgeDrafts:
		return m.cleareddrafts
	case codingproblem.EdgeTestCases:
		return m.clearedtest_cases
	case codingproblem.EdgeSubmissions:
		return m.clearedsubmissions
	case codingproblem.EdgeExtensions:
		return m.clearedextensions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CodingProblemMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown CodingProblem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CodingProblemMutation) ResetEdge(name string) error {
	switch name {
	case codingproblem.EdgeDrafts:
		m.ResetDrafts()
		return nil
	case codingproblem.EdgeTestCases:
		m.ResetTestCases()
		return nil
	case codingproblem.EdgeSubmissions:
		m.ResetSubmissions()
		return nil
	case codingproblem.EdgeExtensions:
		m.ResetExtensions()
		return nil
	}
	return fmt.Errorf("unknown CodingProblem edge %s", name)
}

// CodingSubmissionMutation represents an operation that mutates the CodingSubmission nodes in the graph.
type CodingSubmissionMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	create_time           *time.Time
	update_time           *time.Time
	code                  *string
	is_validation         *bool
	status                *codingsubmission.Status
	points                *int
	addpoints             *int
	results               *models.CodingSubmissionResults
	clearedFields         map[string]struct{}
	author                *int
	clearedauthor         bool
	coding_problem        *int
	clearedcoding_problem bool
	staff_data            *int
	clearedstaff_data     bool
	done                  bool
	oldValue              func(context.Context) (*CodingSubmission, error)
	predicates            []predicate.CodingSubmission
}

var _ ent.Mutation = (*CodingSubmissionMutation)(nil)

// codingsubmissionOption allows management of the mutation configuration using functional options.
type codingsubmissionOption func(*CodingSubmissionMutation)

// newCodingSubmissionMutation creates new mutation for the CodingSubmission entity.
func newCodingSubmissionMutation(c config, op Op, opts ...codingsubmissionOption) *CodingSubmissionMutation {
	m := &CodingSubmissionMutation{
		config:        c,
		op:            op,
		typ:           TypeCodingSubmission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCodingSubmissionID sets the ID field of the mutation.
func withCodingSubmissionID(id int) codingsubmissionOption {
	return func(m *CodingSubmissionMutation) {
		var (
			err   error
			once  sync.Once
			value *CodingSubmission
		)
		m.oldValue = func(ctx context.Context) (*CodingSubmission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CodingSubmission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCodingSubmission sets the old CodingSubmission of the mutation.
func withCodingSubmission(node *CodingSubmission) codingsubmissionOption {
	return func(m *CodingSubmissionMutation) {
		m.oldValue = func(context.Context) (*CodingSubmission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CodingSubmissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CodingSubmissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CodingSubmissionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CodingSubmissionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CodingSubmission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *CodingSubmissionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CodingSubmissionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the CodingSubmission entity.
// If the CodingSubmission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingSubmissionMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CodingSubmissionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CodingSubmissionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CodingSubmissionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the CodingSubmission entity.
// If the CodingSubmission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingSubmissionMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CodingSubmissionMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetCode sets the "code" field.
func (m *CodingSubmissionMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *CodingSubmissionMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the CodingSubmission entity.
// If the CodingSubmission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingSubmissionMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *CodingSubmissionMutation) ResetCode() {
	m.code = nil
}

// SetIsValidation sets the "is_validation" field.
func (m *CodingSubmissionMutation) SetIsValidation(b bool) {
	m.is_validation = &b
}

// IsValidation returns the value of the "is_validation" field in the mutation.
func (m *CodingSubmissionMutation) IsValidation() (r bool, exists bool) {
	v := m.is_validation
	if v == nil {
		return
	}
	return *v, true
}

// OldIsValidation returns the old "is_validation" field's value of the CodingSubmission entity.
// If the CodingSubmission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingSubmissionMutation) OldIsValidation(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsValidation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsValidation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsValidation: %w", err)
	}
	return oldValue.IsValidation, nil
}

// ResetIsValidation resets all changes to the "is_validation" field.
func (m *CodingSubmissionMutation) ResetIsValidation() {
	m.is_validation = nil
}

// SetStatus sets the "status" field.
func (m *CodingSubmissionMutation) SetStatus(c codingsubmission.Status) {
	m.status = &c
}

// Status returns the value of the "status" field in the mutation.
func (m *CodingSubmissionMutation) Status() (r codingsubmission.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CodingSubmission entity.
// If the CodingSubmission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingSubmissionMutation) OldStatus(ctx context.Context) (v codingsubmission.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CodingSubmissionMutation) ResetStatus() {
	m.status = nil
}

// SetPoints sets the "points" field.
func (m *CodingSubmissionMutation) SetPoints(i int) {
	m.points = &i
	m.addpoints = nil
}

// Points returns the value of the "points" field in the mutation.
func (m *CodingSubmissionMutation) Points() (r int, exists bool) {
	v := m.points
	if v == nil {
		return
	}
	return *v, true
}

// OldPoints returns the old "points" field's value of the CodingSubmission entity.
// If the CodingSubmission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingSubmissionMutation) OldPoints(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoints is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoints requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoints: %w", err)
	}
	return oldValue.Points, nil
}

// AddPoints adds i to the "points" field.
func (m *CodingSubmissionMutation) AddPoints(i int) {
	if m.addpoints != nil {
		*m.addpoints += i
	} else {
		m.addpoints = &i
	}
}

// AddedPoints returns the value that was added to the "points" field in this mutation.
func (m *CodingSubmissionMutation) AddedPoints() (r int, exists bool) {
	v := m.addpoints
	if v == nil {
		return
	}
	return *v, true
}

// ClearPoints clears the value of the "points" field.
func (m *CodingSubmissionMutation) ClearPoints() {
	m.points = nil
	m.addpoints = nil
	m.clearedFields[codingsubmission.FieldPoints] = struct{}{}
}

// PointsCleared returns if the "points" field was cleared in this mutation.
func (m *CodingSubmissionMutation) PointsCleared() bool {
	_, ok := m.clearedFields[codingsubmission.FieldPoints]
	return ok
}

// ResetPoints resets all changes to the "points" field.
func (m *CodingSubmissionMutation) ResetPoints() {
	m.points = nil
	m.addpoints = nil
	delete(m.clearedFields, codingsubmission.FieldPoints)
}

// SetResults sets the "results" field.
func (m *CodingSubmissionMutation) SetResults(msr models.CodingSubmissionResults) {
	m.results = &msr
}

// Results returns the value of the "results" field in the mutation.
func (m *CodingSubmissionMutation) Results() (r models.CodingSubmissionResults, exists bool) {
	v := m.results
	if v == nil {
		return
	}
	return *v, true
}

// OldResults returns the old "results" field's value of the CodingSubmission entity.
// If the CodingSubmission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingSubmissionMutation) OldResults(ctx context.Context) (v models.CodingSubmissionResults, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResults is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResults requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResults: %w", err)
	}
	return oldValue.Results, nil
}

// ClearResults clears the value of the "results" field.
func (m *CodingSubmissionMutation) ClearResults() {
	m.results = nil
	m.clearedFields[codingsubmission.FieldResults] = struct{}{}
}

// ResultsCleared returns if the "results" field was cleared in this mutation.
func (m *CodingSubmissionMutation) ResultsCleared() bool {
	_, ok := m.clearedFields[codingsubmission.FieldResults]
	return ok
}

// ResetResults resets all changes to the "results" field.
func (m *CodingSubmissionMutation) ResetResults() {
	m.results = nil
	delete(m.clearedFields, codingsubmission.FieldResults)
}

// SetAuthorID sets the "author" edge to the User entity by id.
func (m *CodingSubmissionMutation) SetAuthorID(id int) {
	m.author = &id
}

// ClearAuthor clears the "author" edge to the User entity.
func (m *CodingSubmissionMutation) ClearAuthor() {
	m.clearedauthor = true
}

// AuthorCleared reports if the "author" edge to the User entity was cleared.
func (m *CodingSubmissionMutation) AuthorCleared() bool {
	return m.clearedauthor
}

// AuthorID returns the "author" edge ID in the mutation.
func (m *CodingSubmissionMutation) AuthorID() (id int, exists bool) {
	if m.author != nil {
		return *m.author, true
	}
	return
}

// AuthorIDs returns the "author" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthorID instead. It exists only for internal usage by the builders.
func (m *CodingSubmissionMutation) AuthorIDs() (ids []int) {
	if id := m.author; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthor resets all changes to the "author" edge.
func (m *CodingSubmissionMutation) ResetAuthor() {
	m.author = nil
	m.clearedauthor = false
}

// SetCodingProblemID sets the "coding_problem" edge to the CodingProblem entity by id.
func (m *CodingSubmissionMutation) SetCodingProblemID(id int) {
	m.coding_problem = &id
}

// ClearCodingProblem clears the "coding_problem" edge to the CodingProblem entity.
func (m *CodingSubmissionMutation) ClearCodingProblem() {
	m.clearedcoding_problem = true
}

// CodingProblemCleared reports if the "coding_problem" edge to the CodingProblem entity was cleared.
func (m *CodingSubmissionMutation) CodingProblemCleared() bool {
	return m.clearedcoding_problem
}

// CodingProblemID returns the "coding_problem" edge ID in the mutation.
func (m *CodingSubmissionMutation) CodingProblemID() (id int, exists bool) {
	if m.coding_problem != nil {
		return *m.coding_problem, true
	}
	return
}

// CodingProblemIDs returns the "coding_problem" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CodingProblemID instead. It exists only for internal usage by the builders.
func (m *CodingSubmissionMutation) CodingProblemIDs() (ids []int) {
	if id := m.coding_problem; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCodingProblem resets all changes to the "coding_problem" edge.
func (m *CodingSubmissionMutation) ResetCodingProblem() {
	m.coding_problem = nil
	m.clearedcoding_problem = false
}

// SetStaffDataID sets the "staff_data" edge to the CodingSubmissionStaffData entity by id.
func (m *CodingSubmissionMutation) SetStaffDataID(id int) {
	m.staff_data = &id
}

// ClearStaffData clears the "staff_data" edge to the CodingSubmissionStaffData entity.
func (m *CodingSubmissionMutation) ClearStaffData() {
	m.clearedstaff_data = true
}

// StaffDataCleared reports if the "staff_data" edge to the CodingSubmissionStaffData entity was cleared.
func (m *CodingSubmissionMutation) StaffDataCleared() bool {
	return m.clearedstaff_data
}

// StaffDataID returns the "staff_data" edge ID in the mutation.
func (m *CodingSubmissionMutation) StaffDataID() (id int, exists bool) {
	if m.staff_data != nil {
		return *m.staff_data, true
	}
	return
}

// StaffDataIDs returns the "staff_data" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StaffDataID instead. It exists only for internal usage by the builders.
func (m *CodingSubmissionMutation) StaffDataIDs() (ids []int) {
	if id := m.staff_data; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStaffData resets all changes to the "staff_data" edge.
func (m *CodingSubmissionMutation) ResetStaffData() {
	m.staff_data = nil
	m.clearedstaff_data = false
}

// Where appends a list predicates to the CodingSubmissionMutation builder.
func (m *CodingSubmissionMutation) Where(ps ...predicate.CodingSubmission) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CodingSubmissionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CodingSubmission).
func (m *CodingSubmissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CodingSubmissionMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, codingsubmission.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, codingsubmission.FieldUpdateTime)
	}
	if m.code != nil {
		fields = append(fields, codingsubmission.FieldCode)
	}
	if m.is_validation != nil {
		fields = append(fields, codingsubmission.FieldIsValidation)
	}
	if m.status != nil {
		fields = append(fields, codingsubmission.FieldStatus)
	}
	if m.points != nil {
		fields = append(fields, codingsubmission.FieldPoints)
	}
	if m.results != nil {
		fields = append(fields, codingsubmission.FieldResults)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CodingSubmissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case codingsubmission.FieldCreateTime:
		return m.CreateTime()
	case codingsubmission.FieldUpdateTime:
		return m.UpdateTime()
	case codingsubmission.FieldCode:
		return m.Code()
	case codingsubmission.FieldIsValidation:
		return m.IsValidation()
	case codingsubmission.FieldStatus:
		return m.Status()
	case codingsubmission.FieldPoints:
		return m.Points()
	case codingsubmission.FieldResults:
		return m.Results()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CodingSubmissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case codingsubmission.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case codingsubmission.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case codingsubmission.FieldCode:
		return m.OldCode(ctx)
	case codingsubmission.FieldIsValidation:
		return m.OldIsValidation(ctx)
	case codingsubmission.FieldStatus:
		return m.OldStatus(ctx)
	case codingsubmission.FieldPoints:
		return m.OldPoints(ctx)
	case codingsubmission.FieldResults:
		return m.OldResults(ctx)
	}
	return nil, fmt.Errorf("unknown CodingSubmission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CodingSubmissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case codingsubmission.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case codingsubmission.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case codingsubmission.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case codingsubmission.FieldIsValidation:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsValidation(v)
		return nil
	case codingsubmission.FieldStatus:
		v, ok := value.(codingsubmission.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case codingsubmission.FieldPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoints(v)
		return nil
	case codingsubmission.FieldResults:
		v, ok := value.(models.CodingSubmissionResults)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResults(v)
		return nil
	}
	return fmt.Errorf("unknown CodingSubmission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CodingSubmissionMutation) AddedFields() []string {
	var fields []string
	if m.addpoints != nil {
		fields = append(fields, codingsubmission.FieldPoints)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CodingSubmissionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case codingsubmission.FieldPoints:
		return m.AddedPoints()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CodingSubmissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case codingsubmission.FieldPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPoints(v)
		return nil
	}
	return fmt.Errorf("unknown CodingSubmission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CodingSubmissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(codingsubmission.FieldPoints) {
		fields = append(fields, codingsubmission.FieldPoints)
	}
	if m.FieldCleared(codingsubmission.FieldResults) {
		fields = append(fields, codingsubmission.FieldResults)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CodingSubmissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CodingSubmissionMutation) ClearField(name string) error {
	switch name {
	case codingsubmission.FieldPoints:
		m.ClearPoints()
		return nil
	case codingsubmission.FieldResults:
		m.ClearResults()
		return nil
	}
	return fmt.Errorf("unknown CodingSubmission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CodingSubmissionMutation) ResetField(name string) error {
	switch name {
	case codingsubmission.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case codingsubmission.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case codingsubmission.FieldCode:
		m.ResetCode()
		return nil
	case codingsubmission.FieldIsValidation:
		m.ResetIsValidation()
		return nil
	case codingsubmission.FieldStatus:
		m.ResetStatus()
		return nil
	case codingsubmission.FieldPoints:
		m.ResetPoints()
		return nil
	case codingsubmission.FieldResults:
		m.ResetResults()
		return nil
	}
	return fmt.Errorf("unknown CodingSubmission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CodingSubmissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.author != nil {
		edges = append(edges, codingsubmission.EdgeAuthor)
	}
	if m.coding_problem != nil {
		edges = append(edges, codingsubmission.EdgeCodingProblem)
	}
	if m.staff_data != nil {
		edges = append(edges, codingsubmission.EdgeStaffData)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CodingSubmissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case codingsubmission.EdgeAuthor:
		if id := m.author; id != nil {
			return []ent.Value{*id}
		}
	case codingsubmission.EdgeCodingProblem:
		if id := m.coding_problem; id != nil {
			return []ent.Value{*id}
		}
	case codingsubmission.EdgeStaffData:
		if id := m.staff_data; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CodingSubmissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CodingSubmissionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CodingSubmissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedauthor {
		edges = append(edges, codingsubmission.EdgeAuthor)
	}
	if m.clearedcoding_problem {
		edges = append(edges, codingsubmission.EdgeCodingProblem)
	}
	if m.clearedstaff_data {
		edges = append(edges, codingsubmission.EdgeStaffData)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CodingSubmissionMutation) EdgeCleared(name string) bool {
	switch name {
	case codingsubmission.EdgeAuthor:
		return m.clearedauthor
	case codingsubmission.EdgeCodingProblem:
		return m.clearedcoding_problem
	case codingsubmission.EdgeStaffData:
		return m.clearedstaff_data
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CodingSubmissionMutation) ClearEdge(name string) error {
	switch name {
	case codingsubmission.EdgeAuthor:
		m.ClearAuthor()
		return nil
	case codingsubmission.EdgeCodingProblem:
		m.ClearCodingProblem()
		return nil
	case codingsubmission.EdgeStaffData:
		m.ClearStaffData()
		return nil
	}
	return fmt.Errorf("unknown CodingSubmission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CodingSubmissionMutation) ResetEdge(name string) error {
	switch name {
	case codingsubmission.EdgeAuthor:
		m.ResetAuthor()
		return nil
	case codingsubmission.EdgeCodingProblem:
		m.ResetCodingProblem()
		return nil
	case codingsubmission.EdgeStaffData:
		m.ResetStaffData()
		return nil
	}
	return fmt.Errorf("unknown CodingSubmission edge %s", name)
}

// CodingSubmissionStaffDataMutation represents an operation that mutates the CodingSubmissionStaffData nodes in the graph.
type CodingSubmissionStaffDataMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	create_time              *time.Time
	update_time              *time.Time
	execution_id             *int64
	addexecution_id          *int64
	input                    *string
	output                   *string
	stderr                   *string
	exit_error               *string
	clearedFields            map[string]struct{}
	coding_submission        *int
	clearedcoding_submission bool
	done                     bool
	oldValue                 func(context.Context) (*CodingSubmissionStaffData, error)
	predicates               []predicate.CodingSubmissionStaffData
}

var _ ent.Mutation = (*CodingSubmissionStaffDataMutation)(nil)

// codingsubmissionstaffdataOption allows management of the mutation configuration using functional options.
type codingsubmissionstaffdataOption func(*CodingSubmissionStaffDataMutation)

// newCodingSubmissionStaffDataMutation creates new mutation for the CodingSubmissionStaffData entity.
func newCodingSubmissionStaffDataMutation(c config, op Op, opts ...codingsubmissionstaffdataOption) *CodingSubmissionStaffDataMutation {
	m := &CodingSubmissionStaffDataMutation{
		config:        c,
		op:            op,
		typ:           TypeCodingSubmissionStaffData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCodingSubmissionStaffDataID sets the ID field of the mutation.
func withCodingSubmissionStaffDataID(id int) codingsubmissionstaffdataOption {
	return func(m *CodingSubmissionStaffDataMutation) {
		var (
			err   error
			once  sync.Once
			value *CodingSubmissionStaffData
		)
		m.oldValue = func(ctx context.Context) (*CodingSubmissionStaffData, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CodingSubmissionStaffData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCodingSubmissionStaffData sets the old CodingSubmissionStaffData of the mutation.
func withCodingSubmissionStaffData(node *CodingSubmissionStaffData) codingsubmissionstaffdataOption {
	return func(m *CodingSubmissionStaffDataMutation) {
		m.oldValue = func(context.Context) (*CodingSubmissionStaffData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CodingSubmissionStaffDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CodingSubmissionStaffDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CodingSubmissionStaffDataMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CodingSubmissionStaffDataMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CodingSubmissionStaffData.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *CodingSubmissionStaffDataMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CodingSubmissionStaffDataMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the CodingSubmissionStaffData entity.
// If the CodingSubmissionStaffData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingSubmissionStaffDataMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CodingSubmissionStaffDataMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CodingSubmissionStaffDataMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CodingSubmissionStaffDataMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the CodingSubmissionStaffData entity.
// If the CodingSubmissionStaffData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingSubmissionStaffDataMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CodingSubmissionStaffDataMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetExecutionID sets the "execution_id" field.
func (m *CodingSubmissionStaffDataMutation) SetExecutionID(i int64) {
	m.execution_id = &i
	m.addexecution_id = nil
}

// ExecutionID returns the value of the "execution_id" field in the mutation.
func (m *CodingSubmissionStaffDataMutation) ExecutionID() (r int64, exists bool) {
	v := m.execution_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExecutionID returns the old "execution_id" field's value of the CodingSubmissionStaffData entity.
// If the CodingSubmissionStaffData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingSubmissionStaffDataMutation) OldExecutionID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecutionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecutionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecutionID: %w", err)
	}
	return oldValue.ExecutionID, nil
}

// AddExecutionID adds i to the "execution_id" field.
func (m *CodingSubmissionStaffDataMutation) AddExecutionID(i int64) {
	if m.addexecution_id != nil {
		*m.addexecution_id += i
	} else {
		m.addexecution_id = &i
	}
}

// AddedExecutionID returns the value that was added to the "execution_id" field in this mutation.
func (m *CodingSubmissionStaffDataMutation) AddedExecutionID() (r int64, exists bool) {
	v := m.addexecution_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearExecutionID clears the value of the "execution_id" field.
func (m *CodingSubmissionStaffDataMutation) ClearExecutionID() {
	m.execution_id = nil
	m.addexecution_id = nil
	m.clearedFields[codingsubmissionstaffdata.FieldExecutionID] = struct{}{}
}

// ExecutionIDCleared returns if the "execution_id" field was cleared in this mutation.
func (m *CodingSubmissionStaffDataMutation) ExecutionIDCleared() bool {
	_, ok := m.clearedFields[codingsubmissionstaffdata.FieldExecutionID]
	return ok
}

// ResetExecutionID resets all changes to the "execution_id" field.
func (m *CodingSubmissionStaffDataMutation) ResetExecutionID() {
	m.execution_id = nil
	m.addexecution_id = nil
	delete(m.clearedFields, codingsubmissionstaffdata.FieldExecutionID)
}

// SetInput sets the "input" field.
func (m *CodingSubmissionStaffDataMutation) SetInput(s string) {
	m.input = &s
}

// Input returns the value of the "input" field in the mutation.
func (m *CodingSubmissionStaffDataMutation) Input() (r string, exists bool) {
	v := m.input
	if v == nil {
		return
	}
	return *v, true
}

// OldInput returns the old "input" field's value of the CodingSubmissionStaffData entity.
// If the CodingSubmissionStaffData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingSubmissionStaffDataMutation) OldInput(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInput: %w", err)
	}
	return oldValue.Input, nil
}

// ResetInput resets all changes to the "input" field.
func (m *CodingSubmissionStaffDataMutation) ResetInput() {
	m.input = nil
}

// SetOutput sets the "output" field.
func (m *CodingSubmissionStaffDataMutation) SetOutput(s string) {
	m.output = &s
}

// Output returns the value of the "output" field in the mutation.
func (m *CodingSubmissionStaffDataMutation) Output() (r string, exists bool) {
	v := m.output
	if v == nil {
		return
	}
	return *v, true
}

// OldOutput returns the old "output" field's value of the CodingSubmissionStaffData entity.
// If the CodingSubmissionStaffData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingSubmissionStaffDataMutation) OldOutput(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutput: %w", err)
	}
	return oldValue.Output, nil
}

// ClearOutput clears the value of the "output" field.
func (m *CodingSubmissionStaffDataMutation) ClearOutput() {
	m.output = nil
	m.clearedFields[codingsubmissionstaffdata.FieldOutput] = struct{}{}
}

// OutputCleared returns if the "output" field was cleared in this mutation.
func (m *CodingSubmissionStaffDataMutation) OutputCleared() bool {
	_, ok := m.clearedFields[codingsubmissionstaffdata.FieldOutput]
	return ok
}

// ResetOutput resets all changes to the "output" field.
func (m *CodingSubmissionStaffDataMutation) ResetOutput() {
	m.output = nil
	delete(m.clearedFields, codingsubmissionstaffdata.FieldOutput)
}

// SetStderr sets the "stderr" field.
func (m *CodingSubmissionStaffDataMutation) SetStderr(s string) {
	m.stderr = &s
}

// Stderr returns the value of the "stderr" field in the mutation.
func (m *CodingSubmissionStaffDataMutation) Stderr() (r string, exists bool) {
	v := m.stderr
	if v == nil {
		return
	}
	return *v, true
}

// OldStderr returns the old "stderr" field's value of the CodingSubmissionStaffData entity.
// If the CodingSubmissionStaffData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingSubmissionStaffDataMutation) OldStderr(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStderr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStderr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStderr: %w", err)
	}
	return oldValue.Stderr, nil
}

// ClearStderr clears the value of the "stderr" field.
func (m *CodingSubmissionStaffDataMutation) ClearStderr() {
	m.stderr = nil
	m.clearedFields[codingsubmissionstaffdata.FieldStderr] = struct{}{}
}

// StderrCleared returns if the "stderr" field was cleared in this mutation.
func (m *CodingSubmissionStaffDataMutation) StderrCleared() bool {
	_, ok := m.clearedFields[codingsubmissionstaffdata.FieldStderr]
	return ok
}

// ResetStderr resets all changes to the "stderr" field.
func (m *CodingSubmissionStaffDataMutation) ResetStderr() {
	m.stderr = nil
	delete(m.clearedFields, codingsubmissionstaffdata.FieldStderr)
}

// SetExitError sets the "exit_error" field.
func (m *CodingSubmissionStaffDataMutation) SetExitError(s string) {
	m.exit_error = &s
}

// ExitError returns the value of the "exit_error" field in the mutation.
func (m *CodingSubmissionStaffDataMutation) ExitError() (r string, exists bool) {
	v := m.exit_error
	if v == nil {
		return
	}
	return *v, true
}

// OldExitError returns the old "exit_error" field's value of the CodingSubmissionStaffData entity.
// If the CodingSubmissionStaffData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingSubmissionStaffDataMutation) OldExitError(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExitError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExitError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExitError: %w", err)
	}
	return oldValue.ExitError, nil
}

// ClearExitError clears the value of the "exit_error" field.
func (m *CodingSubmissionStaffDataMutation) ClearExitError() {
	m.exit_error = nil
	m.clearedFields[codingsubmissionstaffdata.FieldExitError] = struct{}{}
}

// ExitErrorCleared returns if the "exit_error" field was cleared in this mutation.
func (m *CodingSubmissionStaffDataMutation) ExitErrorCleared() bool {
	_, ok := m.clearedFields[codingsubmissionstaffdata.FieldExitError]
	return ok
}

// ResetExitError resets all changes to the "exit_error" field.
func (m *CodingSubmissionStaffDataMutation) ResetExitError() {
	m.exit_error = nil
	delete(m.clearedFields, codingsubmissionstaffdata.FieldExitError)
}

// SetCodingSubmissionID sets the "coding_submission" edge to the CodingSubmission entity by id.
func (m *CodingSubmissionStaffDataMutation) SetCodingSubmissionID(id int) {
	m.coding_submission = &id
}

// ClearCodingSubmission clears the "coding_submission" edge to the CodingSubmission entity.
func (m *CodingSubmissionStaffDataMutation) ClearCodingSubmission() {
	m.clearedcoding_submission = true
}

// CodingSubmissionCleared reports if the "coding_submission" edge to the CodingSubmission entity was cleared.
func (m *CodingSubmissionStaffDataMutation) CodingSubmissionCleared() bool {
	return m.clearedcoding_submission
}

// CodingSubmissionID returns the "coding_submission" edge ID in the mutation.
func (m *CodingSubmissionStaffDataMutation) CodingSubmissionID() (id int, exists bool) {
	if m.coding_submission != nil {
		return *m.coding_submission, true
	}
	return
}

// CodingSubmissionIDs returns the "coding_submission" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CodingSubmissionID instead. It exists only for internal usage by the builders.
func (m *CodingSubmissionStaffDataMutation) CodingSubmissionIDs() (ids []int) {
	if id := m.coding_submission; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCodingSubmission resets all changes to the "coding_submission" edge.
func (m *CodingSubmissionStaffDataMutation) ResetCodingSubmission() {
	m.coding_submission = nil
	m.clearedcoding_submission = false
}

// Where appends a list predicates to the CodingSubmissionStaffDataMutation builder.
func (m *CodingSubmissionStaffDataMutation) Where(ps ...predicate.CodingSubmissionStaffData) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CodingSubmissionStaffDataMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CodingSubmissionStaffData).
func (m *CodingSubmissionStaffDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CodingSubmissionStaffDataMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, codingsubmissionstaffdata.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, codingsubmissionstaffdata.FieldUpdateTime)
	}
	if m.execution_id != nil {
		fields = append(fields, codingsubmissionstaffdata.FieldExecutionID)
	}
	if m.input != nil {
		fields = append(fields, codingsubmissionstaffdata.FieldInput)
	}
	if m.output != nil {
		fields = append(fields, codingsubmissionstaffdata.FieldOutput)
	}
	if m.stderr != nil {
		fields = append(fields, codingsubmissionstaffdata.FieldStderr)
	}
	if m.exit_error != nil {
		fields = append(fields, codingsubmissionstaffdata.FieldExitError)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CodingSubmissionStaffDataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case codingsubmissionstaffdata.FieldCreateTime:
		return m.CreateTime()
	case codingsubmissionstaffdata.FieldUpdateTime:
		return m.UpdateTime()
	case codingsubmissionstaffdata.FieldExecutionID:
		return m.ExecutionID()
	case codingsubmissionstaffdata.FieldInput:
		return m.Input()
	case codingsubmissionstaffdata.FieldOutput:
		return m.Output()
	case codingsubmissionstaffdata.FieldStderr:
		return m.Stderr()
	case codingsubmissionstaffdata.FieldExitError:
		return m.ExitError()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CodingSubmissionStaffDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case codingsubmissionstaffdata.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case codingsubmissionstaffdata.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case codingsubmissionstaffdata.FieldExecutionID:
		return m.OldExecutionID(ctx)
	case codingsubmissionstaffdata.FieldInput:
		return m.OldInput(ctx)
	case codingsubmissionstaffdata.FieldOutput:
		return m.OldOutput(ctx)
	case codingsubmissionstaffdata.FieldStderr:
		return m.OldStderr(ctx)
	case codingsubmissionstaffdata.FieldExitError:
		return m.OldExitError(ctx)
	}
	return nil, fmt.Errorf("unknown CodingSubmissionStaffData field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CodingSubmissionStaffDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case codingsubmissionstaffdata.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case codingsubmissionstaffdata.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case codingsubmissionstaffdata.FieldExecutionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecutionID(v)
		return nil
	case codingsubmissionstaffdata.FieldInput:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInput(v)
		return nil
	case codingsubmissionstaffdata.FieldOutput:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutput(v)
		return nil
	case codingsubmissionstaffdata.FieldStderr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStderr(v)
		return nil
	case codingsubmissionstaffdata.FieldExitError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExitError(v)
		return nil
	}
	return fmt.Errorf("unknown CodingSubmissionStaffData field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CodingSubmissionStaffDataMutation) AddedFields() []string {
	var fields []string
	if m.addexecution_id != nil {
		fields = append(fields, codingsubmissionstaffdata.FieldExecutionID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CodingSubmissionStaffDataMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case codingsubmissionstaffdata.FieldExecutionID:
		return m.AddedExecutionID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CodingSubmissionStaffDataMutation) AddField(name string, value ent.Value) error {
	switch name {
	case codingsubmissionstaffdata.FieldExecutionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExecutionID(v)
		return nil
	}
	return fmt.Errorf("unknown CodingSubmissionStaffData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CodingSubmissionStaffDataMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(codingsubmissionstaffdata.FieldExecutionID) {
		fields = append(fields, codingsubmissionstaffdata.FieldExecutionID)
	}
	if m.FieldCleared(codingsubmissionstaffdata.FieldOutput) {
		fields = append(fields, codingsubmissionstaffdata.FieldOutput)
	}
	if m.FieldCleared(codingsubmissionstaffdata.FieldStderr) {
		fields = append(fields, codingsubmissionstaffdata.FieldStderr)
	}
	if m.FieldCleared(codingsubmissionstaffdata.FieldExitError) {
		fields = append(fields, codingsubmissionstaffdata.FieldExitError)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CodingSubmissionStaffDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CodingSubmissionStaffDataMutation) ClearField(name string) error {
	switch name {
	case codingsubmissionstaffdata.FieldExecutionID:
		m.ClearExecutionID()
		return nil
	case codingsubmissionstaffdata.FieldOutput:
		m.ClearOutput()
		return nil
	case codingsubmissionstaffdata.FieldStderr:
		m.ClearStderr()
		return nil
	case codingsubmissionstaffdata.FieldExitError:
		m.ClearExitError()
		return nil
	}
	return fmt.Errorf("unknown CodingSubmissionStaffData nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CodingSubmissionStaffDataMutation) ResetField(name string) error {
	switch name {
	case codingsubmissionstaffdata.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case codingsubmissionstaffdata.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case codingsubmissionstaffdata.FieldExecutionID:
		m.ResetExecutionID()
		return nil
	case codingsubmissionstaffdata.FieldInput:
		m.ResetInput()
		return nil
	case codingsubmissionstaffdata.FieldOutput:
		m.ResetOutput()
		return nil
	case codingsubmissionstaffdata.FieldStderr:
		m.ResetStderr()
		return nil
	case codingsubmissionstaffdata.FieldExitError:
		m.ResetExitError()
		return nil
	}
	return fmt.Errorf("unknown CodingSubmissionStaffData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CodingSubmissionStaffDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.coding_submission != nil {
		edges = append(edges, codingsubmissionstaffdata.EdgeCodingSubmission)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CodingSubmissionStaffDataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case codingsubmissionstaffdata.EdgeCodingSubmission:
		if id := m.coding_submission; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CodingSubmissionStaffDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CodingSubmissionStaffDataMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CodingSubmissionStaffDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcoding_submission {
		edges = append(edges, codingsubmissionstaffdata.EdgeCodingSubmission)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CodingSubmissionStaffDataMutation) EdgeCleared(name string) bool {
	switch name {
	case codingsubmissionstaffdata.EdgeCodingSubmission:
		return m.clearedcoding_submission
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CodingSubmissionStaffDataMutation) ClearEdge(name string) error {
	switch name {
	case codingsubmissionstaffdata.EdgeCodingSubmission:
		m.ClearCodingSubmission()
		return nil
	}
	return fmt.Errorf("unknown CodingSubmissionStaffData unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CodingSubmissionStaffDataMutation) ResetEdge(name string) error {
	switch name {
	case codingsubmissionstaffdata.EdgeCodingSubmission:
		m.ResetCodingSubmission()
		return nil
	}
	return fmt.Errorf("unknown CodingSubmissionStaffData edge %s", name)
}

// CodingTestCaseMutation represents an operation that mutates the CodingTestCase nodes in the graph.
type CodingTestCaseMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	create_time           *time.Time
	update_time           *time.Time
	points                *int
	addpoints             *int
	visibility            *codingtestcase.Visibility
	clearedFields         map[string]struct{}
	coding_problem        *int
	clearedcoding_problem bool
	data                  *int
	cleareddata           bool
	done                  bool
	oldValue              func(context.Context) (*CodingTestCase, error)
	predicates            []predicate.CodingTestCase
}

var _ ent.Mutation = (*CodingTestCaseMutation)(nil)

// codingtestcaseOption allows management of the mutation configuration using functional options.
type codingtestcaseOption func(*CodingTestCaseMutation)

// newCodingTestCaseMutation creates new mutation for the CodingTestCase entity.
func newCodingTestCaseMutation(c config, op Op, opts ...codingtestcaseOption) *CodingTestCaseMutation {
	m := &CodingTestCaseMutation{
		config:        c,
		op:            op,
		typ:           TypeCodingTestCase,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCodingTestCaseID sets the ID field of the mutation.
func withCodingTestCaseID(id int) codingtestcaseOption {
	return func(m *CodingTestCaseMutation) {
		var (
			err   error
			once  sync.Once
			value *CodingTestCase
		)
		m.oldValue = func(ctx context.Context) (*CodingTestCase, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CodingTestCase.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCodingTestCase sets the old CodingTestCase of the mutation.
func withCodingTestCase(node *CodingTestCase) codingtestcaseOption {
	return func(m *CodingTestCaseMutation) {
		m.oldValue = func(context.Context) (*CodingTestCase, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CodingTestCaseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CodingTestCaseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CodingTestCaseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CodingTestCaseMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CodingTestCase.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *CodingTestCaseMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CodingTestCaseMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the CodingTestCase entity.
// If the CodingTestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingTestCaseMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CodingTestCaseMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CodingTestCaseMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CodingTestCaseMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the CodingTestCase entity.
// If the CodingTestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingTestCaseMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CodingTestCaseMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetPoints sets the "points" field.
func (m *CodingTestCaseMutation) SetPoints(i int) {
	m.points = &i
	m.addpoints = nil
}

// Points returns the value of the "points" field in the mutation.
func (m *CodingTestCaseMutation) Points() (r int, exists bool) {
	v := m.points
	if v == nil {
		return
	}
	return *v, true
}

// OldPoints returns the old "points" field's value of the CodingTestCase entity.
// If the CodingTestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingTestCaseMutation) OldPoints(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoints is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoints requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoints: %w", err)
	}
	return oldValue.Points, nil
}

// AddPoints adds i to the "points" field.
func (m *CodingTestCaseMutation) AddPoints(i int) {
	if m.addpoints != nil {
		*m.addpoints += i
	} else {
		m.addpoints = &i
	}
}

// AddedPoints returns the value that was added to the "points" field in this mutation.
func (m *CodingTestCaseMutation) AddedPoints() (r int, exists bool) {
	v := m.addpoints
	if v == nil {
		return
	}
	return *v, true
}

// ResetPoints resets all changes to the "points" field.
func (m *CodingTestCaseMutation) ResetPoints() {
	m.points = nil
	m.addpoints = nil
}

// SetVisibility sets the "visibility" field.
func (m *CodingTestCaseMutation) SetVisibility(c codingtestcase.Visibility) {
	m.visibility = &c
}

// Visibility returns the value of the "visibility" field in the mutation.
func (m *CodingTestCaseMutation) Visibility() (r codingtestcase.Visibility, exists bool) {
	v := m.visibility
	if v == nil {
		return
	}
	return *v, true
}

// OldVisibility returns the old "visibility" field's value of the CodingTestCase entity.
// If the CodingTestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingTestCaseMutation) OldVisibility(ctx context.Context) (v codingtestcase.Visibility, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisibility is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisibility requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisibility: %w", err)
	}
	return oldValue.Visibility, nil
}

// ResetVisibility resets all changes to the "visibility" field.
func (m *CodingTestCaseMutation) ResetVisibility() {
	m.visibility = nil
}

// SetCodingProblemID sets the "coding_problem" edge to the CodingProblem entity by id.
func (m *CodingTestCaseMutation) SetCodingProblemID(id int) {
	m.coding_problem = &id
}

// ClearCodingProblem clears the "coding_problem" edge to the CodingProblem entity.
func (m *CodingTestCaseMutation) ClearCodingProblem() {
	m.clearedcoding_problem = true
}

// CodingProblemCleared reports if the "coding_problem" edge to the CodingProblem entity was cleared.
func (m *CodingTestCaseMutation) CodingProblemCleared() bool {
	return m.clearedcoding_problem
}

// CodingProblemID returns the "coding_problem" edge ID in the mutation.
func (m *CodingTestCaseMutation) CodingProblemID() (id int, exists bool) {
	if m.coding_problem != nil {
		return *m.coding_problem, true
	}
	return
}

// CodingProblemIDs returns the "coding_problem" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CodingProblemID instead. It exists only for internal usage by the builders.
func (m *CodingTestCaseMutation) CodingProblemIDs() (ids []int) {
	if id := m.coding_problem; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCodingProblem resets all changes to the "coding_problem" edge.
func (m *CodingTestCaseMutation) ResetCodingProblem() {
	m.coding_problem = nil
	m.clearedcoding_problem = false
}

// SetDataID sets the "data" edge to the CodingTestCaseData entity by id.
func (m *CodingTestCaseMutation) SetDataID(id int) {
	m.data = &id
}

// ClearData clears the "data" edge to the CodingTestCaseData entity.
func (m *CodingTestCaseMutation) ClearData() {
	m.cleareddata = true
}

// DataCleared reports if the "data" edge to the CodingTestCaseData entity was cleared.
func (m *CodingTestCaseMutation) DataCleared() bool {
	return m.cleareddata
}

// DataID returns the "data" edge ID in the mutation.
func (m *CodingTestCaseMutation) DataID() (id int, exists bool) {
	if m.data != nil {
		return *m.data, true
	}
	return
}

// DataIDs returns the "data" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DataID instead. It exists only for internal usage by the builders.
func (m *CodingTestCaseMutation) DataIDs() (ids []int) {
	if id := m.data; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetData resets all changes to the "data" edge.
func (m *CodingTestCaseMutation) ResetData() {
	m.data = nil
	m.cleareddata = false
}

// Where appends a list predicates to the CodingTestCaseMutation builder.
func (m *CodingTestCaseMutation) Where(ps ...predicate.CodingTestCase) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CodingTestCaseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CodingTestCase).
func (m *CodingTestCaseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CodingTestCaseMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, codingtestcase.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, codingtestcase.FieldUpdateTime)
	}
	if m.points != nil {
		fields = append(fields, codingtestcase.FieldPoints)
	}
	if m.visibility != nil {
		fields = append(fields, codingtestcase.FieldVisibility)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CodingTestCaseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case codingtestcase.FieldCreateTime:
		return m.CreateTime()
	case codingtestcase.FieldUpdateTime:
		return m.UpdateTime()
	case codingtestcase.FieldPoints:
		return m.Points()
	case codingtestcase.FieldVisibility:
		return m.Visibility()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CodingTestCaseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case codingtestcase.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case codingtestcase.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case codingtestcase.FieldPoints:
		return m.OldPoints(ctx)
	case codingtestcase.FieldVisibility:
		return m.OldVisibility(ctx)
	}
	return nil, fmt.Errorf("unknown CodingTestCase field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CodingTestCaseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case codingtestcase.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case codingtestcase.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case codingtestcase.FieldPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoints(v)
		return nil
	case codingtestcase.FieldVisibility:
		v, ok := value.(codingtestcase.Visibility)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisibility(v)
		return nil
	}
	return fmt.Errorf("unknown CodingTestCase field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CodingTestCaseMutation) AddedFields() []string {
	var fields []string
	if m.addpoints != nil {
		fields = append(fields, codingtestcase.FieldPoints)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CodingTestCaseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case codingtestcase.FieldPoints:
		return m.AddedPoints()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CodingTestCaseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case codingtestcase.FieldPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPoints(v)
		return nil
	}
	return fmt.Errorf("unknown CodingTestCase numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CodingTestCaseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CodingTestCaseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CodingTestCaseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CodingTestCase nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CodingTestCaseMutation) ResetField(name string) error {
	switch name {
	case codingtestcase.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case codingtestcase.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case codingtestcase.FieldPoints:
		m.ResetPoints()
		return nil
	case codingtestcase.FieldVisibility:
		m.ResetVisibility()
		return nil
	}
	return fmt.Errorf("unknown CodingTestCase field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CodingTestCaseMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.coding_problem != nil {
		edges = append(edges, codingtestcase.EdgeCodingProblem)
	}
	if m.data != nil {
		edges = append(edges, codingtestcase.EdgeData)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CodingTestCaseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case codingtestcase.EdgeCodingProblem:
		if id := m.coding_problem; id != nil {
			return []ent.Value{*id}
		}
	case codingtestcase.EdgeData:
		if id := m.data; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CodingTestCaseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CodingTestCaseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CodingTestCaseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcoding_problem {
		edges = append(edges, codingtestcase.EdgeCodingProblem)
	}
	if m.cleareddata {
		edges = append(edges, codingtestcase.EdgeData)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CodingTestCaseMutation) EdgeCleared(name string) bool {
	switch name {
	case codingtestcase.EdgeCodingProblem:
		return m.clearedcoding_problem
	case codingtestcase.EdgeData:
		return m.cleareddata
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CodingTestCaseMutation) ClearEdge(name string) error {
	switch name {
	case codingtestcase.EdgeCodingProblem:
		m.ClearCodingProblem()
		return nil
	case codingtestcase.EdgeData:
		m.ClearData()
		return nil
	}
	return fmt.Errorf("unknown CodingTestCase unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CodingTestCaseMutation) ResetEdge(name string) error {
	switch name {
	case codingtestcase.EdgeCodingProblem:
		m.ResetCodingProblem()
		return nil
	case codingtestcase.EdgeData:
		m.ResetData()
		return nil
	}
	return fmt.Errorf("unknown CodingTestCase edge %s", name)
}

// CodingTestCaseDataMutation represents an operation that mutates the CodingTestCaseData nodes in the graph.
type CodingTestCaseDataMutation struct {
	config
	op               Op
	typ              string
	id               *int
	create_time      *time.Time
	update_time      *time.Time
	input            *string
	output           *string
	clearedFields    map[string]struct{}
	test_case        *int
	clearedtest_case bool
	done             bool
	oldValue         func(context.Context) (*CodingTestCaseData, error)
	predicates       []predicate.CodingTestCaseData
}

var _ ent.Mutation = (*CodingTestCaseDataMutation)(nil)

// codingtestcasedataOption allows management of the mutation configuration using functional options.
type codingtestcasedataOption func(*CodingTestCaseDataMutation)

// newCodingTestCaseDataMutation creates new mutation for the CodingTestCaseData entity.
func newCodingTestCaseDataMutation(c config, op Op, opts ...codingtestcasedataOption) *CodingTestCaseDataMutation {
	m := &CodingTestCaseDataMutation{
		config:        c,
		op:            op,
		typ:           TypeCodingTestCaseData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCodingTestCaseDataID sets the ID field of the mutation.
func withCodingTestCaseDataID(id int) codingtestcasedataOption {
	return func(m *CodingTestCaseDataMutation) {
		var (
			err   error
			once  sync.Once
			value *CodingTestCaseData
		)
		m.oldValue = func(ctx context.Context) (*CodingTestCaseData, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CodingTestCaseData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCodingTestCaseData sets the old CodingTestCaseData of the mutation.
func withCodingTestCaseData(node *CodingTestCaseData) codingtestcasedataOption {
	return func(m *CodingTestCaseDataMutation) {
		m.oldValue = func(context.Context) (*CodingTestCaseData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CodingTestCaseDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CodingTestCaseDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CodingTestCaseDataMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CodingTestCaseDataMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CodingTestCaseData.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *CodingTestCaseDataMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CodingTestCaseDataMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the CodingTestCaseData entity.
// If the CodingTestCaseData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingTestCaseDataMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CodingTestCaseDataMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CodingTestCaseDataMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CodingTestCaseDataMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the CodingTestCaseData entity.
// If the CodingTestCaseData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingTestCaseDataMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CodingTestCaseDataMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetInput sets the "input" field.
func (m *CodingTestCaseDataMutation) SetInput(s string) {
	m.input = &s
}

// Input returns the value of the "input" field in the mutation.
func (m *CodingTestCaseDataMutation) Input() (r string, exists bool) {
	v := m.input
	if v == nil {
		return
	}
	return *v, true
}

// OldInput returns the old "input" field's value of the CodingTestCaseData entity.
// If the CodingTestCaseData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingTestCaseDataMutation) OldInput(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInput: %w", err)
	}
	return oldValue.Input, nil
}

// ResetInput resets all changes to the "input" field.
func (m *CodingTestCaseDataMutation) ResetInput() {
	m.input = nil
}

// SetOutput sets the "output" field.
func (m *CodingTestCaseDataMutation) SetOutput(s string) {
	m.output = &s
}

// Output returns the value of the "output" field in the mutation.
func (m *CodingTestCaseDataMutation) Output() (r string, exists bool) {
	v := m.output
	if v == nil {
		return
	}
	return *v, true
}

// OldOutput returns the old "output" field's value of the CodingTestCaseData entity.
// If the CodingTestCaseData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingTestCaseDataMutation) OldOutput(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutput: %w", err)
	}
	return oldValue.Output, nil
}

// ResetOutput resets all changes to the "output" field.
func (m *CodingTestCaseDataMutation) ResetOutput() {
	m.output = nil
}

// SetTestCaseID sets the "test_case" edge to the CodingTestCase entity by id.
func (m *CodingTestCaseDataMutation) SetTestCaseID(id int) {
	m.test_case = &id
}

// ClearTestCase clears the "test_case" edge to the CodingTestCase entity.
func (m *CodingTestCaseDataMutation) ClearTestCase() {
	m.clearedtest_case = true
}

// TestCaseCleared reports if the "test_case" edge to the CodingTestCase entity was cleared.
func (m *CodingTestCaseDataMutation) TestCaseCleared() bool {
	return m.clearedtest_case
}

// TestCaseID returns the "test_case" edge ID in the mutation.
func (m *CodingTestCaseDataMutation) TestCaseID() (id int, exists bool) {
	if m.test_case != nil {
		return *m.test_case, true
	}
	return
}

// TestCaseIDs returns the "test_case" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TestCaseID instead. It exists only for internal usage by the builders.
func (m *CodingTestCaseDataMutation) TestCaseIDs() (ids []int) {
	if id := m.test_case; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTestCase resets all changes to the "test_case" edge.
func (m *CodingTestCaseDataMutation) ResetTestCase() {
	m.test_case = nil
	m.clearedtest_case = false
}

// Where appends a list predicates to the CodingTestCaseDataMutation builder.
func (m *CodingTestCaseDataMutation) Where(ps ...predicate.CodingTestCaseData) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CodingTestCaseDataMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CodingTestCaseData).
func (m *CodingTestCaseDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CodingTestCaseDataMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, codingtestcasedata.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, codingtestcasedata.FieldUpdateTime)
	}
	if m.input != nil {
		fields = append(fields, codingtestcasedata.FieldInput)
	}
	if m.output != nil {
		fields = append(fields, codingtestcasedata.FieldOutput)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CodingTestCaseDataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case codingtestcasedata.FieldCreateTime:
		return m.CreateTime()
	case codingtestcasedata.FieldUpdateTime:
		return m.UpdateTime()
	case codingtestcasedata.FieldInput:
		return m.Input()
	case codingtestcasedata.FieldOutput:
		return m.Output()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CodingTestCaseDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case codingtestcasedata.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case codingtestcasedata.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case codingtestcasedata.FieldInput:
		return m.OldInput(ctx)
	case codingtestcasedata.FieldOutput:
		return m.OldOutput(ctx)
	}
	return nil, fmt.Errorf("unknown CodingTestCaseData field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CodingTestCaseDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case codingtestcasedata.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case codingtestcasedata.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case codingtestcasedata.FieldInput:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInput(v)
		return nil
	case codingtestcasedata.FieldOutput:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutput(v)
		return nil
	}
	return fmt.Errorf("unknown CodingTestCaseData field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CodingTestCaseDataMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CodingTestCaseDataMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CodingTestCaseDataMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CodingTestCaseData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CodingTestCaseDataMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CodingTestCaseDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CodingTestCaseDataMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CodingTestCaseData nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CodingTestCaseDataMutation) ResetField(name string) error {
	switch name {
	case codingtestcasedata.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case codingtestcasedata.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case codingtestcasedata.FieldInput:
		m.ResetInput()
		return nil
	case codingtestcasedata.FieldOutput:
		m.ResetOutput()
		return nil
	}
	return fmt.Errorf("unknown CodingTestCaseData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CodingTestCaseDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.test_case != nil {
		edges = append(edges, codingtestcasedata.EdgeTestCase)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CodingTestCaseDataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case codingtestcasedata.EdgeTestCase:
		if id := m.test_case; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CodingTestCaseDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CodingTestCaseDataMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CodingTestCaseDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtest_case {
		edges = append(edges, codingtestcasedata.EdgeTestCase)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CodingTestCaseDataMutation) EdgeCleared(name string) bool {
	switch name {
	case codingtestcasedata.EdgeTestCase:
		return m.clearedtest_case
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CodingTestCaseDataMutation) ClearEdge(name string) error {
	switch name {
	case codingtestcasedata.EdgeTestCase:
		m.ClearTestCase()
		return nil
	}
	return fmt.Errorf("unknown CodingTestCaseData unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CodingTestCaseDataMutation) ResetEdge(name string) error {
	switch name {
	case codingtestcasedata.EdgeTestCase:
		m.ResetTestCase()
		return nil
	}
	return fmt.Errorf("unknown CodingTestCaseData edge %s", name)
}

// ProjectScoreMutation represents an operation that mutates the ProjectScore nodes in the graph.
type ProjectScoreMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	case_id       *int32
	addcase_id    *int32
	score         *float64
	addscore      *float64
	_type         *projectscore.Type
	clearedFields map[string]struct{}
	team          *int
	clearedteam   bool
	done          bool
	oldValue      func(context.Context) (*ProjectScore, error)
	predicates    []predicate.ProjectScore
}

var _ ent.Mutation = (*ProjectScoreMutation)(nil)

// projectscoreOption allows management of the mutation configuration using functional options.
type projectscoreOption func(*ProjectScoreMutation)

// newProjectScoreMutation creates new mutation for the ProjectScore entity.
func newProjectScoreMutation(c config, op Op, opts ...projectscoreOption) *ProjectScoreMutation {
	m := &ProjectScoreMutation{
		config:        c,
		op:            op,
		typ:           TypeProjectScore,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectScoreID sets the ID field of the mutation.
func withProjectScoreID(id int) projectscoreOption {
	return func(m *ProjectScoreMutation) {
		var (
			err   error
			once  sync.Once
			value *ProjectScore
		)
		m.oldValue = func(ctx context.Context) (*ProjectScore, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProjectScore.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProjectScore sets the old ProjectScore of the mutation.
func withProjectScore(node *ProjectScore) projectscoreOption {
	return func(m *ProjectScoreMutation) {
		m.oldValue = func(context.Context) (*ProjectScore, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectScoreMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectScoreMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectScoreMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectScoreMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProjectScore.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *ProjectScoreMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ProjectScoreMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ProjectScore entity.
// If the ProjectScore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectScoreMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ProjectScoreMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ProjectScoreMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ProjectScoreMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ProjectScore entity.
// If the ProjectScore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectScoreMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ProjectScoreMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetCaseID sets the "case_id" field.
func (m *ProjectScoreMutation) SetCaseID(i int32) {
	m.case_id = &i
	m.addcase_id = nil
}

// CaseID returns the value of the "case_id" field in the mutation.
func (m *ProjectScoreMutation) CaseID() (r int32, exists bool) {
	v := m.case_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCaseID returns the old "case_id" field's value of the ProjectScore entity.
// If the ProjectScore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectScoreMutation) OldCaseID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaseID: %w", err)
	}
	return oldValue.CaseID, nil
}

// AddCaseID adds i to the "case_id" field.
func (m *ProjectScoreMutation) AddCaseID(i int32) {
	if m.addcase_id != nil {
		*m.addcase_id += i
	} else {
		m.addcase_id = &i
	}
}

// AddedCaseID returns the value that was added to the "case_id" field in this mutation.
func (m *ProjectScoreMutation) AddedCaseID() (r int32, exists bool) {
	v := m.addcase_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCaseID resets all changes to the "case_id" field.
func (m *ProjectScoreMutation) ResetCaseID() {
	m.case_id = nil
	m.addcase_id = nil
}

// SetScore sets the "score" field.
func (m *ProjectScoreMutation) SetScore(f float64) {
	m.score = &f
	m.addscore = nil
}

// Score returns the value of the "score" field in the mutation.
func (m *ProjectScoreMutation) Score() (r float64, exists bool) {
	v := m.score
	if v == nil {
		return
	}
	return *v, true
}

// OldScore returns the old "score" field's value of the ProjectScore entity.
// If the ProjectScore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectScoreMutation) OldScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScore: %w", err)
	}
	return oldValue.Score, nil
}

// AddScore adds f to the "score" field.
func (m *ProjectScoreMutation) AddScore(f float64) {
	if m.addscore != nil {
		*m.addscore += f
	} else {
		m.addscore = &f
	}
}

// AddedScore returns the value that was added to the "score" field in this mutation.
func (m *ProjectScoreMutation) AddedScore() (r float64, exists bool) {
	v := m.addscore
	if v == nil {
		return
	}
	return *v, true
}

// ResetScore resets all changes to the "score" field.
func (m *ProjectScoreMutation) ResetScore() {
	m.score = nil
	m.addscore = nil
}

// SetType sets the "type" field.
func (m *ProjectScoreMutation) SetType(pr projectscore.Type) {
	m._type = &pr
}

// GetType returns the value of the "type" field in the mutation.
func (m *ProjectScoreMutation) GetType() (r projectscore.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ProjectScore entity.
// If the ProjectScore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectScoreMutation) OldType(ctx context.Context) (v projectscore.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ProjectScoreMutation) ResetType() {
	m._type = nil
}

// SetTeamID sets the "team" edge to the ProjectTeam entity by id.
func (m *ProjectScoreMutation) SetTeamID(id int) {
	m.team = &id
}

// ClearTeam clears the "team" edge to the ProjectTeam entity.
func (m *ProjectScoreMutation) ClearTeam() {
	m.clearedteam = true
}

// TeamCleared reports if the "team" edge to the ProjectTeam entity was cleared.
func (m *ProjectScoreMutation) TeamCleared() bool {
	return m.clearedteam
}

// TeamID returns the "team" edge ID in the mutation.
func (m *ProjectScoreMutation) TeamID() (id int, exists bool) {
	if m.team != nil {
		return *m.team, true
	}
	return
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *ProjectScoreMutation) TeamIDs() (ids []int) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *ProjectScoreMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// Where appends a list predicates to the ProjectScoreMutation builder.
func (m *ProjectScoreMutation) Where(ps ...predicate.ProjectScore) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProjectScoreMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProjectScore).
func (m *ProjectScoreMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectScoreMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, projectscore.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, projectscore.FieldUpdateTime)
	}
	if m.case_id != nil {
		fields = append(fields, projectscore.FieldCaseID)
	}
	if m.score != nil {
		fields = append(fields, projectscore.FieldScore)
	}
	if m._type != nil {
		fields = append(fields, projectscore.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectScoreMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case projectscore.FieldCreateTime:
		return m.CreateTime()
	case projectscore.FieldUpdateTime:
		return m.UpdateTime()
	case projectscore.FieldCaseID:
		return m.CaseID()
	case projectscore.FieldScore:
		return m.Score()
	case projectscore.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectScoreMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case projectscore.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case projectscore.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case projectscore.FieldCaseID:
		return m.OldCaseID(ctx)
	case projectscore.FieldScore:
		return m.OldScore(ctx)
	case projectscore.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown ProjectScore field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectScoreMutation) SetField(name string, value ent.Value) error {
	switch name {
	case projectscore.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case projectscore.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case projectscore.FieldCaseID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaseID(v)
		return nil
	case projectscore.FieldScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScore(v)
		return nil
	case projectscore.FieldType:
		v, ok := value.(projectscore.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectScore field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectScoreMutation) AddedFields() []string {
	var fields []string
	if m.addcase_id != nil {
		fields = append(fields, projectscore.FieldCaseID)
	}
	if m.addscore != nil {
		fields = append(fields, projectscore.FieldScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectScoreMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case projectscore.FieldCaseID:
		return m.AddedCaseID()
	case projectscore.FieldScore:
		return m.AddedScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectScoreMutation) AddField(name string, value ent.Value) error {
	switch name {
	case projectscore.FieldCaseID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCaseID(v)
		return nil
	case projectscore.FieldScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScore(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectScore numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectScoreMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectScoreMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectScoreMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProjectScore nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectScoreMutation) ResetField(name string) error {
	switch name {
	case projectscore.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case projectscore.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case projectscore.FieldCaseID:
		m.ResetCaseID()
		return nil
	case projectscore.FieldScore:
		m.ResetScore()
		return nil
	case projectscore.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown ProjectScore field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectScoreMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.team != nil {
		edges = append(edges, projectscore.EdgeTeam)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectScoreMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case projectscore.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectScoreMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectScoreMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectScoreMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedteam {
		edges = append(edges, projectscore.EdgeTeam)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectScoreMutation) EdgeCleared(name string) bool {
	switch name {
	case projectscore.EdgeTeam:
		return m.clearedteam
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectScoreMutation) ClearEdge(name string) error {
	switch name {
	case projectscore.EdgeTeam:
		m.ClearTeam()
		return nil
	}
	return fmt.Errorf("unknown ProjectScore unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectScoreMutation) ResetEdge(name string) error {
	switch name {
	case projectscore.EdgeTeam:
		m.ResetTeam()
		return nil
	}
	return fmt.Errorf("unknown ProjectScore edge %s", name)
}

// ProjectTeamMutation represents an operation that mutates the ProjectTeam nodes in the graph.
type ProjectTeamMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	team_id       *int32
	addteam_id    *int32
	name          *string
	clearedFields map[string]struct{}
	scores        map[int]struct{}
	removedscores map[int]struct{}
	clearedscores bool
	done          bool
	oldValue      func(context.Context) (*ProjectTeam, error)
	predicates    []predicate.ProjectTeam
}

var _ ent.Mutation = (*ProjectTeamMutation)(nil)

// projectteamOption allows management of the mutation configuration using functional options.
type projectteamOption func(*ProjectTeamMutation)

// newProjectTeamMutation creates new mutation for the ProjectTeam entity.
func newProjectTeamMutation(c config, op Op, opts ...projectteamOption) *ProjectTeamMutation {
	m := &ProjectTeamMutation{
		config:        c,
		op:            op,
		typ:           TypeProjectTeam,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectTeamID sets the ID field of the mutation.
func withProjectTeamID(id int) projectteamOption {
	return func(m *ProjectTeamMutation) {
		var (
			err   error
			once  sync.Once
			value *ProjectTeam
		)
		m.oldValue = func(ctx context.Context) (*ProjectTeam, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProjectTeam.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProjectTeam sets the old ProjectTeam of the mutation.
func withProjectTeam(node *ProjectTeam) projectteamOption {
	return func(m *ProjectTeamMutation) {
		m.oldValue = func(context.Context) (*ProjectTeam, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectTeamMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectTeamMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectTeamMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectTeamMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProjectTeam.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *ProjectTeamMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ProjectTeamMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ProjectTeam entity.
// If the ProjectTeam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTeamMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ProjectTeamMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ProjectTeamMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ProjectTeamMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ProjectTeam entity.
// If the ProjectTeam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTeamMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ProjectTeamMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetTeamID sets the "team_id" field.
func (m *ProjectTeamMutation) SetTeamID(i int32) {
	m.team_id = &i
	m.addteam_id = nil
}

// TeamID returns the value of the "team_id" field in the mutation.
func (m *ProjectTeamMutation) TeamID() (r int32, exists bool) {
	v := m.team_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamID returns the old "team_id" field's value of the ProjectTeam entity.
// If the ProjectTeam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTeamMutation) OldTeamID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamID: %w", err)
	}
	return oldValue.TeamID, nil
}

// AddTeamID adds i to the "team_id" field.
func (m *ProjectTeamMutation) AddTeamID(i int32) {
	if m.addteam_id != nil {
		*m.addteam_id += i
	} else {
		m.addteam_id = &i
	}
}

// AddedTeamID returns the value that was added to the "team_id" field in this mutation.
func (m *ProjectTeamMutation) AddedTeamID() (r int32, exists bool) {
	v := m.addteam_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTeamID resets all changes to the "team_id" field.
func (m *ProjectTeamMutation) ResetTeamID() {
	m.team_id = nil
	m.addteam_id = nil
}

// SetName sets the "name" field.
func (m *ProjectTeamMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProjectTeamMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ProjectTeam entity.
// If the ProjectTeam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTeamMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProjectTeamMutation) ResetName() {
	m.name = nil
}

// AddScoreIDs adds the "scores" edge to the ProjectScore entity by ids.
func (m *ProjectTeamMutation) AddScoreIDs(ids ...int) {
	if m.scores == nil {
		m.scores = make(map[int]struct{})
	}
	for i := range ids {
		m.scores[ids[i]] = struct{}{}
	}
}

// ClearScores clears the "scores" edge to the ProjectScore entity.
func (m *ProjectTeamMutation) ClearScores() {
	m.clearedscores = true
}

// ScoresCleared reports if the "scores" edge to the ProjectScore entity was cleared.
func (m *ProjectTeamMutation) ScoresCleared() bool {
	return m.clearedscores
}

// RemoveScoreIDs removes the "scores" edge to the ProjectScore entity by IDs.
func (m *ProjectTeamMutation) RemoveScoreIDs(ids ...int) {
	if m.removedscores == nil {
		m.removedscores = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.scores, ids[i])
		m.removedscores[ids[i]] = struct{}{}
	}
}

// RemovedScores returns the removed IDs of the "scores" edge to the ProjectScore entity.
func (m *ProjectTeamMutation) RemovedScoresIDs() (ids []int) {
	for id := range m.removedscores {
		ids = append(ids, id)
	}
	return
}

// ScoresIDs returns the "scores" edge IDs in the mutation.
func (m *ProjectTeamMutation) ScoresIDs() (ids []int) {
	for id := range m.scores {
		ids = append(ids, id)
	}
	return
}

// ResetScores resets all changes to the "scores" edge.
func (m *ProjectTeamMutation) ResetScores() {
	m.scores = nil
	m.clearedscores = false
	m.removedscores = nil
}

// Where appends a list predicates to the ProjectTeamMutation builder.
func (m *ProjectTeamMutation) Where(ps ...predicate.ProjectTeam) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProjectTeamMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProjectTeam).
func (m *ProjectTeamMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectTeamMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, projectteam.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, projectteam.FieldUpdateTime)
	}
	if m.team_id != nil {
		fields = append(fields, projectteam.FieldTeamID)
	}
	if m.name != nil {
		fields = append(fields, projectteam.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectTeamMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case projectteam.FieldCreateTime:
		return m.CreateTime()
	case projectteam.FieldUpdateTime:
		return m.UpdateTime()
	case projectteam.FieldTeamID:
		return m.TeamID()
	case projectteam.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectTeamMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case projectteam.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case projectteam.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case projectteam.FieldTeamID:
		return m.OldTeamID(ctx)
	case projectteam.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown ProjectTeam field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectTeamMutation) SetField(name string, value ent.Value) error {
	switch name {
	case projectteam.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case projectteam.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case projectteam.FieldTeamID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamID(v)
		return nil
	case projectteam.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectTeam field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectTeamMutation) AddedFields() []string {
	var fields []string
	if m.addteam_id != nil {
		fields = append(fields, projectteam.FieldTeamID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectTeamMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case projectteam.FieldTeamID:
		return m.AddedTeamID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectTeamMutation) AddField(name string, value ent.Value) error {
	switch name {
	case projectteam.FieldTeamID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTeamID(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectTeam numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectTeamMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectTeamMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectTeamMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProjectTeam nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectTeamMutation) ResetField(name string) error {
	switch name {
	case projectteam.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case projectteam.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case projectteam.FieldTeamID:
		m.ResetTeamID()
		return nil
	case projectteam.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown ProjectTeam field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectTeamMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.scores != nil {
		edges = append(edges, projectteam.EdgeScores)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectTeamMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case projectteam.EdgeScores:
		ids := make([]ent.Value, 0, len(m.scores))
		for id := range m.scores {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectTeamMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedscores != nil {
		edges = append(edges, projectteam.EdgeScores)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectTeamMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case projectteam.EdgeScores:
		ids := make([]ent.Value, 0, len(m.removedscores))
		for id := range m.removedscores {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectTeamMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedscores {
		edges = append(edges, projectteam.EdgeScores)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectTeamMutation) EdgeCleared(name string) bool {
	switch name {
	case projectteam.EdgeScores:
		return m.clearedscores
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectTeamMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ProjectTeam unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectTeamMutation) ResetEdge(name string) error {
	switch name {
	case projectteam.EdgeScores:
		m.ResetScores()
		return nil
	}
	return fmt.Errorf("unknown ProjectTeam edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	create_time        *time.Time
	update_time        *time.Time
	email              *string
	name               *string
	is_staff           *bool
	clearedFields      map[string]struct{}
	drafts             map[int]struct{}
	removeddrafts      map[int]struct{}
	cleareddrafts      bool
	submissions        map[int]struct{}
	removedsubmissions map[int]struct{}
	clearedsubmissions bool
	extensions         map[int]struct{}
	removedextensions  map[int]struct{}
	clearedextensions  bool
	done               bool
	oldValue           func(context.Context) (*User, error)
	predicates         []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *UserMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *UserMutation) ClearName() {
	m.name = nil
	m.clearedFields[user.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *UserMutation) NameCleared() bool {
	_, ok := m.clearedFields[user.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, user.FieldName)
}

// SetIsStaff sets the "is_staff" field.
func (m *UserMutation) SetIsStaff(b bool) {
	m.is_staff = &b
}

// IsStaff returns the value of the "is_staff" field in the mutation.
func (m *UserMutation) IsStaff() (r bool, exists bool) {
	v := m.is_staff
	if v == nil {
		return
	}
	return *v, true
}

// OldIsStaff returns the old "is_staff" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsStaff(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsStaff is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsStaff requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsStaff: %w", err)
	}
	return oldValue.IsStaff, nil
}

// ResetIsStaff resets all changes to the "is_staff" field.
func (m *UserMutation) ResetIsStaff() {
	m.is_staff = nil
}

// AddDraftIDs adds the "drafts" edge to the CodingDraft entity by ids.
func (m *UserMutation) AddDraftIDs(ids ...int) {
	if m.drafts == nil {
		m.drafts = make(map[int]struct{})
	}
	for i := range ids {
		m.drafts[ids[i]] = struct{}{}
	}
}

// ClearDrafts clears the "drafts" edge to the CodingDraft entity.
func (m *UserMutation) ClearDrafts() {
	m.cleareddrafts = true
}

// DraftsCleared reports if the "drafts" edge to the CodingDraft entity was cleared.
func (m *UserMutation) DraftsCleared() bool {
	return m.cleareddrafts
}

// RemoveDraftIDs removes the "drafts" edge to the CodingDraft entity by IDs.
func (m *UserMutation) RemoveDraftIDs(ids ...int) {
	if m.removeddrafts == nil {
		m.removeddrafts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.drafts, ids[i])
		m.removeddrafts[ids[i]] = struct{}{}
	}
}

// RemovedDrafts returns the removed IDs of the "drafts" edge to the CodingDraft entity.
func (m *UserMutation) RemovedDraftsIDs() (ids []int) {
	for id := range m.removeddrafts {
		ids = append(ids, id)
	}
	return
}

// DraftsIDs returns the "drafts" edge IDs in the mutation.
func (m *UserMutation) DraftsIDs() (ids []int) {
	for id := range m.drafts {
		ids = append(ids, id)
	}
	return
}

// ResetDrafts resets all changes to the "drafts" edge.
func (m *UserMutation) ResetDrafts() {
	m.drafts = nil
	m.cleareddrafts = false
	m.removeddrafts = nil
}

// AddSubmissionIDs adds the "submissions" edge to the CodingSubmission entity by ids.
func (m *UserMutation) AddSubmissionIDs(ids ...int) {
	if m.submissions == nil {
		m.submissions = make(map[int]struct{})
	}
	for i := range ids {
		m.submissions[ids[i]] = struct{}{}
	}
}

// ClearSubmissions clears the "submissions" edge to the CodingSubmission entity.
func (m *UserMutation) ClearSubmissions() {
	m.clearedsubmissions = true
}

// SubmissionsCleared reports if the "submissions" edge to the CodingSubmission entity was cleared.
func (m *UserMutation) SubmissionsCleared() bool {
	return m.clearedsubmissions
}

// RemoveSubmissionIDs removes the "submissions" edge to the CodingSubmission entity by IDs.
func (m *UserMutation) RemoveSubmissionIDs(ids ...int) {
	if m.removedsubmissions == nil {
		m.removedsubmissions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.submissions, ids[i])
		m.removedsubmissions[ids[i]] = struct{}{}
	}
}

// RemovedSubmissions returns the removed IDs of the "submissions" edge to the CodingSubmission entity.
func (m *UserMutation) RemovedSubmissionsIDs() (ids []int) {
	for id := range m.removedsubmissions {
		ids = append(ids, id)
	}
	return
}

// SubmissionsIDs returns the "submissions" edge IDs in the mutation.
func (m *UserMutation) SubmissionsIDs() (ids []int) {
	for id := range m.submissions {
		ids = append(ids, id)
	}
	return
}

// ResetSubmissions resets all changes to the "submissions" edge.
func (m *UserMutation) ResetSubmissions() {
	m.submissions = nil
	m.clearedsubmissions = false
	m.removedsubmissions = nil
}

// AddExtensionIDs adds the "extensions" edge to the CodingExtension entity by ids.
func (m *UserMutation) AddExtensionIDs(ids ...int) {
	if m.extensions == nil {
		m.extensions = make(map[int]struct{})
	}
	for i := range ids {
		m.extensions[ids[i]] = struct{}{}
	}
}

// ClearExtensions clears the "extensions" edge to the CodingExtension entity.
func (m *UserMutation) ClearExtensions() {
	m.clearedextensions = true
}

// ExtensionsCleared reports if the "extensions" edge to the CodingExtension entity was cleared.
func (m *UserMutation) ExtensionsCleared() bool {
	return m.clearedextensions
}

// RemoveExtensionIDs removes the "extensions" edge to the CodingExtension entity by IDs.
func (m *UserMutation) RemoveExtensionIDs(ids ...int) {
	if m.removedextensions == nil {
		m.removedextensions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.extensions, ids[i])
		m.removedextensions[ids[i]] = struct{}{}
	}
}

// RemovedExtensions returns the removed IDs of the "extensions" edge to the CodingExtension entity.
func (m *UserMutation) RemovedExtensionsIDs() (ids []int) {
	for id := range m.removedextensions {
		ids = append(ids, id)
	}
	return
}

// ExtensionsIDs returns the "extensions" edge IDs in the mutation.
func (m *UserMutation) ExtensionsIDs() (ids []int) {
	for id := range m.extensions {
		ids = append(ids, id)
	}
	return
}

// ResetExtensions resets all changes to the "extensions" edge.
func (m *UserMutation) ResetExtensions() {
	m.extensions = nil
	m.clearedextensions = false
	m.removedextensions = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, user.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, user.FieldUpdateTime)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.is_staff != nil {
		fields = append(fields, user.FieldIsStaff)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreateTime:
		return m.CreateTime()
	case user.FieldUpdateTime:
		return m.UpdateTime()
	case user.FieldEmail:
		return m.Email()
	case user.FieldName:
		return m.Name()
	case user.FieldIsStaff:
		return m.IsStaff()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case user.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldIsStaff:
		return m.OldIsStaff(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case user.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldIsStaff:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsStaff(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldName) {
		fields = append(fields, user.FieldName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case user.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldIsStaff:
		m.ResetIsStaff()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.drafts != nil {
		edges = append(edges, user.EdgeDrafts)
	}
	if m.submissions != nil {
		edges = append(edges, user.EdgeSubmissions)
	}
	if m.extensions != nil {
		edges = append(edges, user.EdgeExtensions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeDrafts:
		ids := make([]ent.Value, 0, len(m.drafts))
		for id := range m.drafts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubmissions:
		ids := make([]ent.Value, 0, len(m.submissions))
		for id := range m.submissions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeExtensions:
		ids := make([]ent.Value, 0, len(m.extensions))
		for id := range m.extensions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removeddrafts != nil {
		edges = append(edges, user.EdgeDrafts)
	}
	if m.removedsubmissions != nil {
		edges = append(edges, user.EdgeSubmissions)
	}
	if m.removedextensions != nil {
		edges = append(edges, user.EdgeExtensions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeDrafts:
		ids := make([]ent.Value, 0, len(m.removeddrafts))
		for id := range m.removeddrafts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubmissions:
		ids := make([]ent.Value, 0, len(m.removedsubmissions))
		for id := range m.removedsubmissions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeExtensions:
		ids := make([]ent.Value, 0, len(m.removedextensions))
		for id := range m.removedextensions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareddrafts {
		edges = append(edges, user.EdgeDrafts)
	}
	if m.clearedsubmissions {
		edges = append(edges, user.EdgeSubmissions)
	}
	if m.clearedextensions {
		edges = append(edges, user.EdgeExtensions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeDrafts:
		return m.cleareddrafts
	case user.EdgeSubmissions:
		return m.clearedsubmissions
	case user.EdgeExtensions:
		return m.clearedextensions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeDrafts:
		m.ResetDrafts()
		return nil
	case user.EdgeSubmissions:
		m.ResetSubmissions()
		return nil
	case user.EdgeExtensions:
		m.ResetExtensions()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
