// Code generated by entc, DO NOT EDIT.

package generated

import (
	"170-ag/ent/generated/codingdraft"
	"170-ag/ent/generated/codingproblem"
	"170-ag/ent/generated/codingsubmission"
	"170-ag/ent/generated/codingsubmissionstaffdata"
	"170-ag/ent/generated/codingtestcase"
	"170-ag/ent/generated/predicate"
	"170-ag/ent/generated/user"
	"context"
	"fmt"
	"sync"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCodingDraft               = "CodingDraft"
	TypeCodingProblem             = "CodingProblem"
	TypeCodingSubmission          = "CodingSubmission"
	TypeCodingSubmissionStaffData = "CodingSubmissionStaffData"
	TypeCodingTestCase            = "CodingTestCase"
	TypeUser                      = "User"
)

// CodingDraftMutation represents an operation that mutates the CodingDraft nodes in the graph.
type CodingDraftMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	code                  *string
	clearedFields         map[string]struct{}
	author                *int
	clearedauthor         bool
	coding_problem        *int
	clearedcoding_problem bool
	done                  bool
	oldValue              func(context.Context) (*CodingDraft, error)
	predicates            []predicate.CodingDraft
}

var _ ent.Mutation = (*CodingDraftMutation)(nil)

// codingdraftOption allows management of the mutation configuration using functional options.
type codingdraftOption func(*CodingDraftMutation)

// newCodingDraftMutation creates new mutation for the CodingDraft entity.
func newCodingDraftMutation(c config, op Op, opts ...codingdraftOption) *CodingDraftMutation {
	m := &CodingDraftMutation{
		config:        c,
		op:            op,
		typ:           TypeCodingDraft,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCodingDraftID sets the ID field of the mutation.
func withCodingDraftID(id int) codingdraftOption {
	return func(m *CodingDraftMutation) {
		var (
			err   error
			once  sync.Once
			value *CodingDraft
		)
		m.oldValue = func(ctx context.Context) (*CodingDraft, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CodingDraft.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCodingDraft sets the old CodingDraft of the mutation.
func withCodingDraft(node *CodingDraft) codingdraftOption {
	return func(m *CodingDraftMutation) {
		m.oldValue = func(context.Context) (*CodingDraft, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CodingDraftMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CodingDraftMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CodingDraftMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCode sets the "code" field.
func (m *CodingDraftMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *CodingDraftMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the CodingDraft entity.
// If the CodingDraft object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingDraftMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *CodingDraftMutation) ResetCode() {
	m.code = nil
}

// SetAuthorID sets the "author" edge to the User entity by id.
func (m *CodingDraftMutation) SetAuthorID(id int) {
	m.author = &id
}

// ClearAuthor clears the "author" edge to the User entity.
func (m *CodingDraftMutation) ClearAuthor() {
	m.clearedauthor = true
}

// AuthorCleared reports if the "author" edge to the User entity was cleared.
func (m *CodingDraftMutation) AuthorCleared() bool {
	return m.clearedauthor
}

// AuthorID returns the "author" edge ID in the mutation.
func (m *CodingDraftMutation) AuthorID() (id int, exists bool) {
	if m.author != nil {
		return *m.author, true
	}
	return
}

// AuthorIDs returns the "author" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthorID instead. It exists only for internal usage by the builders.
func (m *CodingDraftMutation) AuthorIDs() (ids []int) {
	if id := m.author; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthor resets all changes to the "author" edge.
func (m *CodingDraftMutation) ResetAuthor() {
	m.author = nil
	m.clearedauthor = false
}

// SetCodingProblemID sets the "coding_problem" edge to the CodingProblem entity by id.
func (m *CodingDraftMutation) SetCodingProblemID(id int) {
	m.coding_problem = &id
}

// ClearCodingProblem clears the "coding_problem" edge to the CodingProblem entity.
func (m *CodingDraftMutation) ClearCodingProblem() {
	m.clearedcoding_problem = true
}

// CodingProblemCleared reports if the "coding_problem" edge to the CodingProblem entity was cleared.
func (m *CodingDraftMutation) CodingProblemCleared() bool {
	return m.clearedcoding_problem
}

// CodingProblemID returns the "coding_problem" edge ID in the mutation.
func (m *CodingDraftMutation) CodingProblemID() (id int, exists bool) {
	if m.coding_problem != nil {
		return *m.coding_problem, true
	}
	return
}

// CodingProblemIDs returns the "coding_problem" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CodingProblemID instead. It exists only for internal usage by the builders.
func (m *CodingDraftMutation) CodingProblemIDs() (ids []int) {
	if id := m.coding_problem; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCodingProblem resets all changes to the "coding_problem" edge.
func (m *CodingDraftMutation) ResetCodingProblem() {
	m.coding_problem = nil
	m.clearedcoding_problem = false
}

// Where appends a list predicates to the CodingDraftMutation builder.
func (m *CodingDraftMutation) Where(ps ...predicate.CodingDraft) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CodingDraftMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CodingDraft).
func (m *CodingDraftMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CodingDraftMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.code != nil {
		fields = append(fields, codingdraft.FieldCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CodingDraftMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case codingdraft.FieldCode:
		return m.Code()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CodingDraftMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case codingdraft.FieldCode:
		return m.OldCode(ctx)
	}
	return nil, fmt.Errorf("unknown CodingDraft field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CodingDraftMutation) SetField(name string, value ent.Value) error {
	switch name {
	case codingdraft.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	}
	return fmt.Errorf("unknown CodingDraft field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CodingDraftMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CodingDraftMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CodingDraftMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CodingDraft numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CodingDraftMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CodingDraftMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CodingDraftMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CodingDraft nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CodingDraftMutation) ResetField(name string) error {
	switch name {
	case codingdraft.FieldCode:
		m.ResetCode()
		return nil
	}
	return fmt.Errorf("unknown CodingDraft field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CodingDraftMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.author != nil {
		edges = append(edges, codingdraft.EdgeAuthor)
	}
	if m.coding_problem != nil {
		edges = append(edges, codingdraft.EdgeCodingProblem)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CodingDraftMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case codingdraft.EdgeAuthor:
		if id := m.author; id != nil {
			return []ent.Value{*id}
		}
	case codingdraft.EdgeCodingProblem:
		if id := m.coding_problem; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CodingDraftMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CodingDraftMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CodingDraftMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedauthor {
		edges = append(edges, codingdraft.EdgeAuthor)
	}
	if m.clearedcoding_problem {
		edges = append(edges, codingdraft.EdgeCodingProblem)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CodingDraftMutation) EdgeCleared(name string) bool {
	switch name {
	case codingdraft.EdgeAuthor:
		return m.clearedauthor
	case codingdraft.EdgeCodingProblem:
		return m.clearedcoding_problem
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CodingDraftMutation) ClearEdge(name string) error {
	switch name {
	case codingdraft.EdgeAuthor:
		m.ClearAuthor()
		return nil
	case codingdraft.EdgeCodingProblem:
		m.ClearCodingProblem()
		return nil
	}
	return fmt.Errorf("unknown CodingDraft unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CodingDraftMutation) ResetEdge(name string) error {
	switch name {
	case codingdraft.EdgeAuthor:
		m.ResetAuthor()
		return nil
	case codingdraft.EdgeCodingProblem:
		m.ResetCodingProblem()
		return nil
	}
	return fmt.Errorf("unknown CodingDraft edge %s", name)
}

// CodingProblemMutation represents an operation that mutates the CodingProblem nodes in the graph.
type CodingProblemMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	name               *string
	statement          *string
	released           *bool
	clearedFields      map[string]struct{}
	drafts             map[int]struct{}
	removeddrafts      map[int]struct{}
	cleareddrafts      bool
	test_cases         map[int]struct{}
	removedtest_cases  map[int]struct{}
	clearedtest_cases  bool
	submissions        map[int]struct{}
	removedsubmissions map[int]struct{}
	clearedsubmissions bool
	done               bool
	oldValue           func(context.Context) (*CodingProblem, error)
	predicates         []predicate.CodingProblem
}

var _ ent.Mutation = (*CodingProblemMutation)(nil)

// codingproblemOption allows management of the mutation configuration using functional options.
type codingproblemOption func(*CodingProblemMutation)

// newCodingProblemMutation creates new mutation for the CodingProblem entity.
func newCodingProblemMutation(c config, op Op, opts ...codingproblemOption) *CodingProblemMutation {
	m := &CodingProblemMutation{
		config:        c,
		op:            op,
		typ:           TypeCodingProblem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCodingProblemID sets the ID field of the mutation.
func withCodingProblemID(id int) codingproblemOption {
	return func(m *CodingProblemMutation) {
		var (
			err   error
			once  sync.Once
			value *CodingProblem
		)
		m.oldValue = func(ctx context.Context) (*CodingProblem, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CodingProblem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCodingProblem sets the old CodingProblem of the mutation.
func withCodingProblem(node *CodingProblem) codingproblemOption {
	return func(m *CodingProblemMutation) {
		m.oldValue = func(context.Context) (*CodingProblem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CodingProblemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CodingProblemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CodingProblemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *CodingProblemMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CodingProblemMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CodingProblem entity.
// If the CodingProblem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingProblemMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CodingProblemMutation) ResetName() {
	m.name = nil
}

// SetStatement sets the "statement" field.
func (m *CodingProblemMutation) SetStatement(s string) {
	m.statement = &s
}

// Statement returns the value of the "statement" field in the mutation.
func (m *CodingProblemMutation) Statement() (r string, exists bool) {
	v := m.statement
	if v == nil {
		return
	}
	return *v, true
}

// OldStatement returns the old "statement" field's value of the CodingProblem entity.
// If the CodingProblem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingProblemMutation) OldStatement(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatement is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatement requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatement: %w", err)
	}
	return oldValue.Statement, nil
}

// ResetStatement resets all changes to the "statement" field.
func (m *CodingProblemMutation) ResetStatement() {
	m.statement = nil
}

// SetReleased sets the "released" field.
func (m *CodingProblemMutation) SetReleased(b bool) {
	m.released = &b
}

// Released returns the value of the "released" field in the mutation.
func (m *CodingProblemMutation) Released() (r bool, exists bool) {
	v := m.released
	if v == nil {
		return
	}
	return *v, true
}

// OldReleased returns the old "released" field's value of the CodingProblem entity.
// If the CodingProblem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingProblemMutation) OldReleased(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReleased is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReleased requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReleased: %w", err)
	}
	return oldValue.Released, nil
}

// ResetReleased resets all changes to the "released" field.
func (m *CodingProblemMutation) ResetReleased() {
	m.released = nil
}

// AddDraftIDs adds the "drafts" edge to the CodingDraft entity by ids.
func (m *CodingProblemMutation) AddDraftIDs(ids ...int) {
	if m.drafts == nil {
		m.drafts = make(map[int]struct{})
	}
	for i := range ids {
		m.drafts[ids[i]] = struct{}{}
	}
}

// ClearDrafts clears the "drafts" edge to the CodingDraft entity.
func (m *CodingProblemMutation) ClearDrafts() {
	m.cleareddrafts = true
}

// DraftsCleared reports if the "drafts" edge to the CodingDraft entity was cleared.
func (m *CodingProblemMutation) DraftsCleared() bool {
	return m.cleareddrafts
}

// RemoveDraftIDs removes the "drafts" edge to the CodingDraft entity by IDs.
func (m *CodingProblemMutation) RemoveDraftIDs(ids ...int) {
	if m.removeddrafts == nil {
		m.removeddrafts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.drafts, ids[i])
		m.removeddrafts[ids[i]] = struct{}{}
	}
}

// RemovedDrafts returns the removed IDs of the "drafts" edge to the CodingDraft entity.
func (m *CodingProblemMutation) RemovedDraftsIDs() (ids []int) {
	for id := range m.removeddrafts {
		ids = append(ids, id)
	}
	return
}

// DraftsIDs returns the "drafts" edge IDs in the mutation.
func (m *CodingProblemMutation) DraftsIDs() (ids []int) {
	for id := range m.drafts {
		ids = append(ids, id)
	}
	return
}

// ResetDrafts resets all changes to the "drafts" edge.
func (m *CodingProblemMutation) ResetDrafts() {
	m.drafts = nil
	m.cleareddrafts = false
	m.removeddrafts = nil
}

// AddTestCaseIDs adds the "test_cases" edge to the CodingTestCase entity by ids.
func (m *CodingProblemMutation) AddTestCaseIDs(ids ...int) {
	if m.test_cases == nil {
		m.test_cases = make(map[int]struct{})
	}
	for i := range ids {
		m.test_cases[ids[i]] = struct{}{}
	}
}

// ClearTestCases clears the "test_cases" edge to the CodingTestCase entity.
func (m *CodingProblemMutation) ClearTestCases() {
	m.clearedtest_cases = true
}

// TestCasesCleared reports if the "test_cases" edge to the CodingTestCase entity was cleared.
func (m *CodingProblemMutation) TestCasesCleared() bool {
	return m.clearedtest_cases
}

// RemoveTestCaseIDs removes the "test_cases" edge to the CodingTestCase entity by IDs.
func (m *CodingProblemMutation) RemoveTestCaseIDs(ids ...int) {
	if m.removedtest_cases == nil {
		m.removedtest_cases = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.test_cases, ids[i])
		m.removedtest_cases[ids[i]] = struct{}{}
	}
}

// RemovedTestCases returns the removed IDs of the "test_cases" edge to the CodingTestCase entity.
func (m *CodingProblemMutation) RemovedTestCasesIDs() (ids []int) {
	for id := range m.removedtest_cases {
		ids = append(ids, id)
	}
	return
}

// TestCasesIDs returns the "test_cases" edge IDs in the mutation.
func (m *CodingProblemMutation) TestCasesIDs() (ids []int) {
	for id := range m.test_cases {
		ids = append(ids, id)
	}
	return
}

// ResetTestCases resets all changes to the "test_cases" edge.
func (m *CodingProblemMutation) ResetTestCases() {
	m.test_cases = nil
	m.clearedtest_cases = false
	m.removedtest_cases = nil
}

// AddSubmissionIDs adds the "submissions" edge to the CodingSubmission entity by ids.
func (m *CodingProblemMutation) AddSubmissionIDs(ids ...int) {
	if m.submissions == nil {
		m.submissions = make(map[int]struct{})
	}
	for i := range ids {
		m.submissions[ids[i]] = struct{}{}
	}
}

// ClearSubmissions clears the "submissions" edge to the CodingSubmission entity.
func (m *CodingProblemMutation) ClearSubmissions() {
	m.clearedsubmissions = true
}

// SubmissionsCleared reports if the "submissions" edge to the CodingSubmission entity was cleared.
func (m *CodingProblemMutation) SubmissionsCleared() bool {
	return m.clearedsubmissions
}

// RemoveSubmissionIDs removes the "submissions" edge to the CodingSubmission entity by IDs.
func (m *CodingProblemMutation) RemoveSubmissionIDs(ids ...int) {
	if m.removedsubmissions == nil {
		m.removedsubmissions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.submissions, ids[i])
		m.removedsubmissions[ids[i]] = struct{}{}
	}
}

// RemovedSubmissions returns the removed IDs of the "submissions" edge to the CodingSubmission entity.
func (m *CodingProblemMutation) RemovedSubmissionsIDs() (ids []int) {
	for id := range m.removedsubmissions {
		ids = append(ids, id)
	}
	return
}

// SubmissionsIDs returns the "submissions" edge IDs in the mutation.
func (m *CodingProblemMutation) SubmissionsIDs() (ids []int) {
	for id := range m.submissions {
		ids = append(ids, id)
	}
	return
}

// ResetSubmissions resets all changes to the "submissions" edge.
func (m *CodingProblemMutation) ResetSubmissions() {
	m.submissions = nil
	m.clearedsubmissions = false
	m.removedsubmissions = nil
}

// Where appends a list predicates to the CodingProblemMutation builder.
func (m *CodingProblemMutation) Where(ps ...predicate.CodingProblem) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CodingProblemMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CodingProblem).
func (m *CodingProblemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CodingProblemMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, codingproblem.FieldName)
	}
	if m.statement != nil {
		fields = append(fields, codingproblem.FieldStatement)
	}
	if m.released != nil {
		fields = append(fields, codingproblem.FieldReleased)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CodingProblemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case codingproblem.FieldName:
		return m.Name()
	case codingproblem.FieldStatement:
		return m.Statement()
	case codingproblem.FieldReleased:
		return m.Released()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CodingProblemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case codingproblem.FieldName:
		return m.OldName(ctx)
	case codingproblem.FieldStatement:
		return m.OldStatement(ctx)
	case codingproblem.FieldReleased:
		return m.OldReleased(ctx)
	}
	return nil, fmt.Errorf("unknown CodingProblem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CodingProblemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case codingproblem.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case codingproblem.FieldStatement:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatement(v)
		return nil
	case codingproblem.FieldReleased:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReleased(v)
		return nil
	}
	return fmt.Errorf("unknown CodingProblem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CodingProblemMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CodingProblemMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CodingProblemMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CodingProblem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CodingProblemMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CodingProblemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CodingProblemMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CodingProblem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CodingProblemMutation) ResetField(name string) error {
	switch name {
	case codingproblem.FieldName:
		m.ResetName()
		return nil
	case codingproblem.FieldStatement:
		m.ResetStatement()
		return nil
	case codingproblem.FieldReleased:
		m.ResetReleased()
		return nil
	}
	return fmt.Errorf("unknown CodingProblem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CodingProblemMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.drafts != nil {
		edges = append(edges, codingproblem.EdgeDrafts)
	}
	if m.test_cases != nil {
		edges = append(edges, codingproblem.EdgeTestCases)
	}
	if m.submissions != nil {
		edges = append(edges, codingproblem.EdgeSubmissions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CodingProblemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case codingproblem.EdgeDrafts:
		ids := make([]ent.Value, 0, len(m.drafts))
		for id := range m.drafts {
			ids = append(ids, id)
		}
		return ids
	case codingproblem.EdgeTestCases:
		ids := make([]ent.Value, 0, len(m.test_cases))
		for id := range m.test_cases {
			ids = append(ids, id)
		}
		return ids
	case codingproblem.EdgeSubmissions:
		ids := make([]ent.Value, 0, len(m.submissions))
		for id := range m.submissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CodingProblemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removeddrafts != nil {
		edges = append(edges, codingproblem.EdgeDrafts)
	}
	if m.removedtest_cases != nil {
		edges = append(edges, codingproblem.EdgeTestCases)
	}
	if m.removedsubmissions != nil {
		edges = append(edges, codingproblem.EdgeSubmissions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CodingProblemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case codingproblem.EdgeDrafts:
		ids := make([]ent.Value, 0, len(m.removeddrafts))
		for id := range m.removeddrafts {
			ids = append(ids, id)
		}
		return ids
	case codingproblem.EdgeTestCases:
		ids := make([]ent.Value, 0, len(m.removedtest_cases))
		for id := range m.removedtest_cases {
			ids = append(ids, id)
		}
		return ids
	case codingproblem.EdgeSubmissions:
		ids := make([]ent.Value, 0, len(m.removedsubmissions))
		for id := range m.removedsubmissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CodingProblemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareddrafts {
		edges = append(edges, codingproblem.EdgeDrafts)
	}
	if m.clearedtest_cases {
		edges = append(edges, codingproblem.EdgeTestCases)
	}
	if m.clearedsubmissions {
		edges = append(edges, codingproblem.EdgeSubmissions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CodingProblemMutation) EdgeCleared(name string) bool {
	switch name {
	case codingproblem.EdgeDrafts:
		return m.cleareddrafts
	case codingproblem.EdgeTestCases:
		return m.clearedtest_cases
	case codingproblem.EdgeSubmissions:
		return m.clearedsubmissions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CodingProblemMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown CodingProblem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CodingProblemMutation) ResetEdge(name string) error {
	switch name {
	case codingproblem.EdgeDrafts:
		m.ResetDrafts()
		return nil
	case codingproblem.EdgeTestCases:
		m.ResetTestCases()
		return nil
	case codingproblem.EdgeSubmissions:
		m.ResetSubmissions()
		return nil
	}
	return fmt.Errorf("unknown CodingProblem edge %s", name)
}

// CodingSubmissionMutation represents an operation that mutates the CodingSubmission nodes in the graph.
type CodingSubmissionMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	code                  *string
	status                *codingsubmission.Status
	clearedFields         map[string]struct{}
	author                *int
	clearedauthor         bool
	coding_problem        *int
	clearedcoding_problem bool
	staff_data            *int
	clearedstaff_data     bool
	done                  bool
	oldValue              func(context.Context) (*CodingSubmission, error)
	predicates            []predicate.CodingSubmission
}

var _ ent.Mutation = (*CodingSubmissionMutation)(nil)

// codingsubmissionOption allows management of the mutation configuration using functional options.
type codingsubmissionOption func(*CodingSubmissionMutation)

// newCodingSubmissionMutation creates new mutation for the CodingSubmission entity.
func newCodingSubmissionMutation(c config, op Op, opts ...codingsubmissionOption) *CodingSubmissionMutation {
	m := &CodingSubmissionMutation{
		config:        c,
		op:            op,
		typ:           TypeCodingSubmission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCodingSubmissionID sets the ID field of the mutation.
func withCodingSubmissionID(id int) codingsubmissionOption {
	return func(m *CodingSubmissionMutation) {
		var (
			err   error
			once  sync.Once
			value *CodingSubmission
		)
		m.oldValue = func(ctx context.Context) (*CodingSubmission, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CodingSubmission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCodingSubmission sets the old CodingSubmission of the mutation.
func withCodingSubmission(node *CodingSubmission) codingsubmissionOption {
	return func(m *CodingSubmissionMutation) {
		m.oldValue = func(context.Context) (*CodingSubmission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CodingSubmissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CodingSubmissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CodingSubmissionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCode sets the "code" field.
func (m *CodingSubmissionMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *CodingSubmissionMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the CodingSubmission entity.
// If the CodingSubmission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingSubmissionMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *CodingSubmissionMutation) ResetCode() {
	m.code = nil
}

// SetStatus sets the "status" field.
func (m *CodingSubmissionMutation) SetStatus(c codingsubmission.Status) {
	m.status = &c
}

// Status returns the value of the "status" field in the mutation.
func (m *CodingSubmissionMutation) Status() (r codingsubmission.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CodingSubmission entity.
// If the CodingSubmission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingSubmissionMutation) OldStatus(ctx context.Context) (v codingsubmission.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CodingSubmissionMutation) ResetStatus() {
	m.status = nil
}

// SetAuthorID sets the "author" edge to the User entity by id.
func (m *CodingSubmissionMutation) SetAuthorID(id int) {
	m.author = &id
}

// ClearAuthor clears the "author" edge to the User entity.
func (m *CodingSubmissionMutation) ClearAuthor() {
	m.clearedauthor = true
}

// AuthorCleared reports if the "author" edge to the User entity was cleared.
func (m *CodingSubmissionMutation) AuthorCleared() bool {
	return m.clearedauthor
}

// AuthorID returns the "author" edge ID in the mutation.
func (m *CodingSubmissionMutation) AuthorID() (id int, exists bool) {
	if m.author != nil {
		return *m.author, true
	}
	return
}

// AuthorIDs returns the "author" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthorID instead. It exists only for internal usage by the builders.
func (m *CodingSubmissionMutation) AuthorIDs() (ids []int) {
	if id := m.author; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthor resets all changes to the "author" edge.
func (m *CodingSubmissionMutation) ResetAuthor() {
	m.author = nil
	m.clearedauthor = false
}

// SetCodingProblemID sets the "coding_problem" edge to the CodingProblem entity by id.
func (m *CodingSubmissionMutation) SetCodingProblemID(id int) {
	m.coding_problem = &id
}

// ClearCodingProblem clears the "coding_problem" edge to the CodingProblem entity.
func (m *CodingSubmissionMutation) ClearCodingProblem() {
	m.clearedcoding_problem = true
}

// CodingProblemCleared reports if the "coding_problem" edge to the CodingProblem entity was cleared.
func (m *CodingSubmissionMutation) CodingProblemCleared() bool {
	return m.clearedcoding_problem
}

// CodingProblemID returns the "coding_problem" edge ID in the mutation.
func (m *CodingSubmissionMutation) CodingProblemID() (id int, exists bool) {
	if m.coding_problem != nil {
		return *m.coding_problem, true
	}
	return
}

// CodingProblemIDs returns the "coding_problem" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CodingProblemID instead. It exists only for internal usage by the builders.
func (m *CodingSubmissionMutation) CodingProblemIDs() (ids []int) {
	if id := m.coding_problem; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCodingProblem resets all changes to the "coding_problem" edge.
func (m *CodingSubmissionMutation) ResetCodingProblem() {
	m.coding_problem = nil
	m.clearedcoding_problem = false
}

// SetStaffDataID sets the "staff_data" edge to the CodingSubmissionStaffData entity by id.
func (m *CodingSubmissionMutation) SetStaffDataID(id int) {
	m.staff_data = &id
}

// ClearStaffData clears the "staff_data" edge to the CodingSubmissionStaffData entity.
func (m *CodingSubmissionMutation) ClearStaffData() {
	m.clearedstaff_data = true
}

// StaffDataCleared reports if the "staff_data" edge to the CodingSubmissionStaffData entity was cleared.
func (m *CodingSubmissionMutation) StaffDataCleared() bool {
	return m.clearedstaff_data
}

// StaffDataID returns the "staff_data" edge ID in the mutation.
func (m *CodingSubmissionMutation) StaffDataID() (id int, exists bool) {
	if m.staff_data != nil {
		return *m.staff_data, true
	}
	return
}

// StaffDataIDs returns the "staff_data" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StaffDataID instead. It exists only for internal usage by the builders.
func (m *CodingSubmissionMutation) StaffDataIDs() (ids []int) {
	if id := m.staff_data; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStaffData resets all changes to the "staff_data" edge.
func (m *CodingSubmissionMutation) ResetStaffData() {
	m.staff_data = nil
	m.clearedstaff_data = false
}

// Where appends a list predicates to the CodingSubmissionMutation builder.
func (m *CodingSubmissionMutation) Where(ps ...predicate.CodingSubmission) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CodingSubmissionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CodingSubmission).
func (m *CodingSubmissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CodingSubmissionMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.code != nil {
		fields = append(fields, codingsubmission.FieldCode)
	}
	if m.status != nil {
		fields = append(fields, codingsubmission.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CodingSubmissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case codingsubmission.FieldCode:
		return m.Code()
	case codingsubmission.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CodingSubmissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case codingsubmission.FieldCode:
		return m.OldCode(ctx)
	case codingsubmission.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown CodingSubmission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CodingSubmissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case codingsubmission.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case codingsubmission.FieldStatus:
		v, ok := value.(codingsubmission.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown CodingSubmission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CodingSubmissionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CodingSubmissionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CodingSubmissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CodingSubmission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CodingSubmissionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CodingSubmissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CodingSubmissionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CodingSubmission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CodingSubmissionMutation) ResetField(name string) error {
	switch name {
	case codingsubmission.FieldCode:
		m.ResetCode()
		return nil
	case codingsubmission.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown CodingSubmission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CodingSubmissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.author != nil {
		edges = append(edges, codingsubmission.EdgeAuthor)
	}
	if m.coding_problem != nil {
		edges = append(edges, codingsubmission.EdgeCodingProblem)
	}
	if m.staff_data != nil {
		edges = append(edges, codingsubmission.EdgeStaffData)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CodingSubmissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case codingsubmission.EdgeAuthor:
		if id := m.author; id != nil {
			return []ent.Value{*id}
		}
	case codingsubmission.EdgeCodingProblem:
		if id := m.coding_problem; id != nil {
			return []ent.Value{*id}
		}
	case codingsubmission.EdgeStaffData:
		if id := m.staff_data; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CodingSubmissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CodingSubmissionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CodingSubmissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedauthor {
		edges = append(edges, codingsubmission.EdgeAuthor)
	}
	if m.clearedcoding_problem {
		edges = append(edges, codingsubmission.EdgeCodingProblem)
	}
	if m.clearedstaff_data {
		edges = append(edges, codingsubmission.EdgeStaffData)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CodingSubmissionMutation) EdgeCleared(name string) bool {
	switch name {
	case codingsubmission.EdgeAuthor:
		return m.clearedauthor
	case codingsubmission.EdgeCodingProblem:
		return m.clearedcoding_problem
	case codingsubmission.EdgeStaffData:
		return m.clearedstaff_data
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CodingSubmissionMutation) ClearEdge(name string) error {
	switch name {
	case codingsubmission.EdgeAuthor:
		m.ClearAuthor()
		return nil
	case codingsubmission.EdgeCodingProblem:
		m.ClearCodingProblem()
		return nil
	case codingsubmission.EdgeStaffData:
		m.ClearStaffData()
		return nil
	}
	return fmt.Errorf("unknown CodingSubmission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CodingSubmissionMutation) ResetEdge(name string) error {
	switch name {
	case codingsubmission.EdgeAuthor:
		m.ResetAuthor()
		return nil
	case codingsubmission.EdgeCodingProblem:
		m.ResetCodingProblem()
		return nil
	case codingsubmission.EdgeStaffData:
		m.ResetStaffData()
		return nil
	}
	return fmt.Errorf("unknown CodingSubmission edge %s", name)
}

// CodingSubmissionStaffDataMutation represents an operation that mutates the CodingSubmissionStaffData nodes in the graph.
type CodingSubmissionStaffDataMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	execution_id             *int64
	addexecution_id          *int64
	input                    *string
	output                   *string
	stderr                   *string
	exit_error               *string
	clearedFields            map[string]struct{}
	coding_submission        *int
	clearedcoding_submission bool
	done                     bool
	oldValue                 func(context.Context) (*CodingSubmissionStaffData, error)
	predicates               []predicate.CodingSubmissionStaffData
}

var _ ent.Mutation = (*CodingSubmissionStaffDataMutation)(nil)

// codingsubmissionstaffdataOption allows management of the mutation configuration using functional options.
type codingsubmissionstaffdataOption func(*CodingSubmissionStaffDataMutation)

// newCodingSubmissionStaffDataMutation creates new mutation for the CodingSubmissionStaffData entity.
func newCodingSubmissionStaffDataMutation(c config, op Op, opts ...codingsubmissionstaffdataOption) *CodingSubmissionStaffDataMutation {
	m := &CodingSubmissionStaffDataMutation{
		config:        c,
		op:            op,
		typ:           TypeCodingSubmissionStaffData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCodingSubmissionStaffDataID sets the ID field of the mutation.
func withCodingSubmissionStaffDataID(id int) codingsubmissionstaffdataOption {
	return func(m *CodingSubmissionStaffDataMutation) {
		var (
			err   error
			once  sync.Once
			value *CodingSubmissionStaffData
		)
		m.oldValue = func(ctx context.Context) (*CodingSubmissionStaffData, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CodingSubmissionStaffData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCodingSubmissionStaffData sets the old CodingSubmissionStaffData of the mutation.
func withCodingSubmissionStaffData(node *CodingSubmissionStaffData) codingsubmissionstaffdataOption {
	return func(m *CodingSubmissionStaffDataMutation) {
		m.oldValue = func(context.Context) (*CodingSubmissionStaffData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CodingSubmissionStaffDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CodingSubmissionStaffDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CodingSubmissionStaffDataMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetExecutionID sets the "execution_id" field.
func (m *CodingSubmissionStaffDataMutation) SetExecutionID(i int64) {
	m.execution_id = &i
	m.addexecution_id = nil
}

// ExecutionID returns the value of the "execution_id" field in the mutation.
func (m *CodingSubmissionStaffDataMutation) ExecutionID() (r int64, exists bool) {
	v := m.execution_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExecutionID returns the old "execution_id" field's value of the CodingSubmissionStaffData entity.
// If the CodingSubmissionStaffData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingSubmissionStaffDataMutation) OldExecutionID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExecutionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExecutionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecutionID: %w", err)
	}
	return oldValue.ExecutionID, nil
}

// AddExecutionID adds i to the "execution_id" field.
func (m *CodingSubmissionStaffDataMutation) AddExecutionID(i int64) {
	if m.addexecution_id != nil {
		*m.addexecution_id += i
	} else {
		m.addexecution_id = &i
	}
}

// AddedExecutionID returns the value that was added to the "execution_id" field in this mutation.
func (m *CodingSubmissionStaffDataMutation) AddedExecutionID() (r int64, exists bool) {
	v := m.addexecution_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearExecutionID clears the value of the "execution_id" field.
func (m *CodingSubmissionStaffDataMutation) ClearExecutionID() {
	m.execution_id = nil
	m.addexecution_id = nil
	m.clearedFields[codingsubmissionstaffdata.FieldExecutionID] = struct{}{}
}

// ExecutionIDCleared returns if the "execution_id" field was cleared in this mutation.
func (m *CodingSubmissionStaffDataMutation) ExecutionIDCleared() bool {
	_, ok := m.clearedFields[codingsubmissionstaffdata.FieldExecutionID]
	return ok
}

// ResetExecutionID resets all changes to the "execution_id" field.
func (m *CodingSubmissionStaffDataMutation) ResetExecutionID() {
	m.execution_id = nil
	m.addexecution_id = nil
	delete(m.clearedFields, codingsubmissionstaffdata.FieldExecutionID)
}

// SetInput sets the "input" field.
func (m *CodingSubmissionStaffDataMutation) SetInput(s string) {
	m.input = &s
}

// Input returns the value of the "input" field in the mutation.
func (m *CodingSubmissionStaffDataMutation) Input() (r string, exists bool) {
	v := m.input
	if v == nil {
		return
	}
	return *v, true
}

// OldInput returns the old "input" field's value of the CodingSubmissionStaffData entity.
// If the CodingSubmissionStaffData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingSubmissionStaffDataMutation) OldInput(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInput: %w", err)
	}
	return oldValue.Input, nil
}

// ResetInput resets all changes to the "input" field.
func (m *CodingSubmissionStaffDataMutation) ResetInput() {
	m.input = nil
}

// SetOutput sets the "output" field.
func (m *CodingSubmissionStaffDataMutation) SetOutput(s string) {
	m.output = &s
}

// Output returns the value of the "output" field in the mutation.
func (m *CodingSubmissionStaffDataMutation) Output() (r string, exists bool) {
	v := m.output
	if v == nil {
		return
	}
	return *v, true
}

// OldOutput returns the old "output" field's value of the CodingSubmissionStaffData entity.
// If the CodingSubmissionStaffData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingSubmissionStaffDataMutation) OldOutput(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutput: %w", err)
	}
	return oldValue.Output, nil
}

// ClearOutput clears the value of the "output" field.
func (m *CodingSubmissionStaffDataMutation) ClearOutput() {
	m.output = nil
	m.clearedFields[codingsubmissionstaffdata.FieldOutput] = struct{}{}
}

// OutputCleared returns if the "output" field was cleared in this mutation.
func (m *CodingSubmissionStaffDataMutation) OutputCleared() bool {
	_, ok := m.clearedFields[codingsubmissionstaffdata.FieldOutput]
	return ok
}

// ResetOutput resets all changes to the "output" field.
func (m *CodingSubmissionStaffDataMutation) ResetOutput() {
	m.output = nil
	delete(m.clearedFields, codingsubmissionstaffdata.FieldOutput)
}

// SetStderr sets the "stderr" field.
func (m *CodingSubmissionStaffDataMutation) SetStderr(s string) {
	m.stderr = &s
}

// Stderr returns the value of the "stderr" field in the mutation.
func (m *CodingSubmissionStaffDataMutation) Stderr() (r string, exists bool) {
	v := m.stderr
	if v == nil {
		return
	}
	return *v, true
}

// OldStderr returns the old "stderr" field's value of the CodingSubmissionStaffData entity.
// If the CodingSubmissionStaffData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingSubmissionStaffDataMutation) OldStderr(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStderr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStderr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStderr: %w", err)
	}
	return oldValue.Stderr, nil
}

// ClearStderr clears the value of the "stderr" field.
func (m *CodingSubmissionStaffDataMutation) ClearStderr() {
	m.stderr = nil
	m.clearedFields[codingsubmissionstaffdata.FieldStderr] = struct{}{}
}

// StderrCleared returns if the "stderr" field was cleared in this mutation.
func (m *CodingSubmissionStaffDataMutation) StderrCleared() bool {
	_, ok := m.clearedFields[codingsubmissionstaffdata.FieldStderr]
	return ok
}

// ResetStderr resets all changes to the "stderr" field.
func (m *CodingSubmissionStaffDataMutation) ResetStderr() {
	m.stderr = nil
	delete(m.clearedFields, codingsubmissionstaffdata.FieldStderr)
}

// SetExitError sets the "exit_error" field.
func (m *CodingSubmissionStaffDataMutation) SetExitError(s string) {
	m.exit_error = &s
}

// ExitError returns the value of the "exit_error" field in the mutation.
func (m *CodingSubmissionStaffDataMutation) ExitError() (r string, exists bool) {
	v := m.exit_error
	if v == nil {
		return
	}
	return *v, true
}

// OldExitError returns the old "exit_error" field's value of the CodingSubmissionStaffData entity.
// If the CodingSubmissionStaffData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingSubmissionStaffDataMutation) OldExitError(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExitError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExitError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExitError: %w", err)
	}
	return oldValue.ExitError, nil
}

// ClearExitError clears the value of the "exit_error" field.
func (m *CodingSubmissionStaffDataMutation) ClearExitError() {
	m.exit_error = nil
	m.clearedFields[codingsubmissionstaffdata.FieldExitError] = struct{}{}
}

// ExitErrorCleared returns if the "exit_error" field was cleared in this mutation.
func (m *CodingSubmissionStaffDataMutation) ExitErrorCleared() bool {
	_, ok := m.clearedFields[codingsubmissionstaffdata.FieldExitError]
	return ok
}

// ResetExitError resets all changes to the "exit_error" field.
func (m *CodingSubmissionStaffDataMutation) ResetExitError() {
	m.exit_error = nil
	delete(m.clearedFields, codingsubmissionstaffdata.FieldExitError)
}

// SetCodingSubmissionID sets the "coding_submission" edge to the CodingSubmission entity by id.
func (m *CodingSubmissionStaffDataMutation) SetCodingSubmissionID(id int) {
	m.coding_submission = &id
}

// ClearCodingSubmission clears the "coding_submission" edge to the CodingSubmission entity.
func (m *CodingSubmissionStaffDataMutation) ClearCodingSubmission() {
	m.clearedcoding_submission = true
}

// CodingSubmissionCleared reports if the "coding_submission" edge to the CodingSubmission entity was cleared.
func (m *CodingSubmissionStaffDataMutation) CodingSubmissionCleared() bool {
	return m.clearedcoding_submission
}

// CodingSubmissionID returns the "coding_submission" edge ID in the mutation.
func (m *CodingSubmissionStaffDataMutation) CodingSubmissionID() (id int, exists bool) {
	if m.coding_submission != nil {
		return *m.coding_submission, true
	}
	return
}

// CodingSubmissionIDs returns the "coding_submission" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CodingSubmissionID instead. It exists only for internal usage by the builders.
func (m *CodingSubmissionStaffDataMutation) CodingSubmissionIDs() (ids []int) {
	if id := m.coding_submission; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCodingSubmission resets all changes to the "coding_submission" edge.
func (m *CodingSubmissionStaffDataMutation) ResetCodingSubmission() {
	m.coding_submission = nil
	m.clearedcoding_submission = false
}

// Where appends a list predicates to the CodingSubmissionStaffDataMutation builder.
func (m *CodingSubmissionStaffDataMutation) Where(ps ...predicate.CodingSubmissionStaffData) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CodingSubmissionStaffDataMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CodingSubmissionStaffData).
func (m *CodingSubmissionStaffDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CodingSubmissionStaffDataMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.execution_id != nil {
		fields = append(fields, codingsubmissionstaffdata.FieldExecutionID)
	}
	if m.input != nil {
		fields = append(fields, codingsubmissionstaffdata.FieldInput)
	}
	if m.output != nil {
		fields = append(fields, codingsubmissionstaffdata.FieldOutput)
	}
	if m.stderr != nil {
		fields = append(fields, codingsubmissionstaffdata.FieldStderr)
	}
	if m.exit_error != nil {
		fields = append(fields, codingsubmissionstaffdata.FieldExitError)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CodingSubmissionStaffDataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case codingsubmissionstaffdata.FieldExecutionID:
		return m.ExecutionID()
	case codingsubmissionstaffdata.FieldInput:
		return m.Input()
	case codingsubmissionstaffdata.FieldOutput:
		return m.Output()
	case codingsubmissionstaffdata.FieldStderr:
		return m.Stderr()
	case codingsubmissionstaffdata.FieldExitError:
		return m.ExitError()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CodingSubmissionStaffDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case codingsubmissionstaffdata.FieldExecutionID:
		return m.OldExecutionID(ctx)
	case codingsubmissionstaffdata.FieldInput:
		return m.OldInput(ctx)
	case codingsubmissionstaffdata.FieldOutput:
		return m.OldOutput(ctx)
	case codingsubmissionstaffdata.FieldStderr:
		return m.OldStderr(ctx)
	case codingsubmissionstaffdata.FieldExitError:
		return m.OldExitError(ctx)
	}
	return nil, fmt.Errorf("unknown CodingSubmissionStaffData field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CodingSubmissionStaffDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case codingsubmissionstaffdata.FieldExecutionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecutionID(v)
		return nil
	case codingsubmissionstaffdata.FieldInput:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInput(v)
		return nil
	case codingsubmissionstaffdata.FieldOutput:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutput(v)
		return nil
	case codingsubmissionstaffdata.FieldStderr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStderr(v)
		return nil
	case codingsubmissionstaffdata.FieldExitError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExitError(v)
		return nil
	}
	return fmt.Errorf("unknown CodingSubmissionStaffData field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CodingSubmissionStaffDataMutation) AddedFields() []string {
	var fields []string
	if m.addexecution_id != nil {
		fields = append(fields, codingsubmissionstaffdata.FieldExecutionID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CodingSubmissionStaffDataMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case codingsubmissionstaffdata.FieldExecutionID:
		return m.AddedExecutionID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CodingSubmissionStaffDataMutation) AddField(name string, value ent.Value) error {
	switch name {
	case codingsubmissionstaffdata.FieldExecutionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExecutionID(v)
		return nil
	}
	return fmt.Errorf("unknown CodingSubmissionStaffData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CodingSubmissionStaffDataMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(codingsubmissionstaffdata.FieldExecutionID) {
		fields = append(fields, codingsubmissionstaffdata.FieldExecutionID)
	}
	if m.FieldCleared(codingsubmissionstaffdata.FieldOutput) {
		fields = append(fields, codingsubmissionstaffdata.FieldOutput)
	}
	if m.FieldCleared(codingsubmissionstaffdata.FieldStderr) {
		fields = append(fields, codingsubmissionstaffdata.FieldStderr)
	}
	if m.FieldCleared(codingsubmissionstaffdata.FieldExitError) {
		fields = append(fields, codingsubmissionstaffdata.FieldExitError)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CodingSubmissionStaffDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CodingSubmissionStaffDataMutation) ClearField(name string) error {
	switch name {
	case codingsubmissionstaffdata.FieldExecutionID:
		m.ClearExecutionID()
		return nil
	case codingsubmissionstaffdata.FieldOutput:
		m.ClearOutput()
		return nil
	case codingsubmissionstaffdata.FieldStderr:
		m.ClearStderr()
		return nil
	case codingsubmissionstaffdata.FieldExitError:
		m.ClearExitError()
		return nil
	}
	return fmt.Errorf("unknown CodingSubmissionStaffData nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CodingSubmissionStaffDataMutation) ResetField(name string) error {
	switch name {
	case codingsubmissionstaffdata.FieldExecutionID:
		m.ResetExecutionID()
		return nil
	case codingsubmissionstaffdata.FieldInput:
		m.ResetInput()
		return nil
	case codingsubmissionstaffdata.FieldOutput:
		m.ResetOutput()
		return nil
	case codingsubmissionstaffdata.FieldStderr:
		m.ResetStderr()
		return nil
	case codingsubmissionstaffdata.FieldExitError:
		m.ResetExitError()
		return nil
	}
	return fmt.Errorf("unknown CodingSubmissionStaffData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CodingSubmissionStaffDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.coding_submission != nil {
		edges = append(edges, codingsubmissionstaffdata.EdgeCodingSubmission)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CodingSubmissionStaffDataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case codingsubmissionstaffdata.EdgeCodingSubmission:
		if id := m.coding_submission; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CodingSubmissionStaffDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CodingSubmissionStaffDataMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CodingSubmissionStaffDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcoding_submission {
		edges = append(edges, codingsubmissionstaffdata.EdgeCodingSubmission)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CodingSubmissionStaffDataMutation) EdgeCleared(name string) bool {
	switch name {
	case codingsubmissionstaffdata.EdgeCodingSubmission:
		return m.clearedcoding_submission
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CodingSubmissionStaffDataMutation) ClearEdge(name string) error {
	switch name {
	case codingsubmissionstaffdata.EdgeCodingSubmission:
		m.ClearCodingSubmission()
		return nil
	}
	return fmt.Errorf("unknown CodingSubmissionStaffData unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CodingSubmissionStaffDataMutation) ResetEdge(name string) error {
	switch name {
	case codingsubmissionstaffdata.EdgeCodingSubmission:
		m.ResetCodingSubmission()
		return nil
	}
	return fmt.Errorf("unknown CodingSubmissionStaffData edge %s", name)
}

// CodingTestCaseMutation represents an operation that mutates the CodingTestCase nodes in the graph.
type CodingTestCaseMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	input                 *string
	output                *string
	points                *int
	addpoints             *int
	visible               *bool
	clearedFields         map[string]struct{}
	coding_problem        *int
	clearedcoding_problem bool
	done                  bool
	oldValue              func(context.Context) (*CodingTestCase, error)
	predicates            []predicate.CodingTestCase
}

var _ ent.Mutation = (*CodingTestCaseMutation)(nil)

// codingtestcaseOption allows management of the mutation configuration using functional options.
type codingtestcaseOption func(*CodingTestCaseMutation)

// newCodingTestCaseMutation creates new mutation for the CodingTestCase entity.
func newCodingTestCaseMutation(c config, op Op, opts ...codingtestcaseOption) *CodingTestCaseMutation {
	m := &CodingTestCaseMutation{
		config:        c,
		op:            op,
		typ:           TypeCodingTestCase,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCodingTestCaseID sets the ID field of the mutation.
func withCodingTestCaseID(id int) codingtestcaseOption {
	return func(m *CodingTestCaseMutation) {
		var (
			err   error
			once  sync.Once
			value *CodingTestCase
		)
		m.oldValue = func(ctx context.Context) (*CodingTestCase, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CodingTestCase.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCodingTestCase sets the old CodingTestCase of the mutation.
func withCodingTestCase(node *CodingTestCase) codingtestcaseOption {
	return func(m *CodingTestCaseMutation) {
		m.oldValue = func(context.Context) (*CodingTestCase, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CodingTestCaseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CodingTestCaseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CodingTestCaseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetInput sets the "input" field.
func (m *CodingTestCaseMutation) SetInput(s string) {
	m.input = &s
}

// Input returns the value of the "input" field in the mutation.
func (m *CodingTestCaseMutation) Input() (r string, exists bool) {
	v := m.input
	if v == nil {
		return
	}
	return *v, true
}

// OldInput returns the old "input" field's value of the CodingTestCase entity.
// If the CodingTestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingTestCaseMutation) OldInput(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInput: %w", err)
	}
	return oldValue.Input, nil
}

// ResetInput resets all changes to the "input" field.
func (m *CodingTestCaseMutation) ResetInput() {
	m.input = nil
}

// SetOutput sets the "output" field.
func (m *CodingTestCaseMutation) SetOutput(s string) {
	m.output = &s
}

// Output returns the value of the "output" field in the mutation.
func (m *CodingTestCaseMutation) Output() (r string, exists bool) {
	v := m.output
	if v == nil {
		return
	}
	return *v, true
}

// OldOutput returns the old "output" field's value of the CodingTestCase entity.
// If the CodingTestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingTestCaseMutation) OldOutput(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutput: %w", err)
	}
	return oldValue.Output, nil
}

// ResetOutput resets all changes to the "output" field.
func (m *CodingTestCaseMutation) ResetOutput() {
	m.output = nil
}

// SetPoints sets the "points" field.
func (m *CodingTestCaseMutation) SetPoints(i int) {
	m.points = &i
	m.addpoints = nil
}

// Points returns the value of the "points" field in the mutation.
func (m *CodingTestCaseMutation) Points() (r int, exists bool) {
	v := m.points
	if v == nil {
		return
	}
	return *v, true
}

// OldPoints returns the old "points" field's value of the CodingTestCase entity.
// If the CodingTestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingTestCaseMutation) OldPoints(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPoints is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPoints requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoints: %w", err)
	}
	return oldValue.Points, nil
}

// AddPoints adds i to the "points" field.
func (m *CodingTestCaseMutation) AddPoints(i int) {
	if m.addpoints != nil {
		*m.addpoints += i
	} else {
		m.addpoints = &i
	}
}

// AddedPoints returns the value that was added to the "points" field in this mutation.
func (m *CodingTestCaseMutation) AddedPoints() (r int, exists bool) {
	v := m.addpoints
	if v == nil {
		return
	}
	return *v, true
}

// ResetPoints resets all changes to the "points" field.
func (m *CodingTestCaseMutation) ResetPoints() {
	m.points = nil
	m.addpoints = nil
}

// SetVisible sets the "visible" field.
func (m *CodingTestCaseMutation) SetVisible(b bool) {
	m.visible = &b
}

// Visible returns the value of the "visible" field in the mutation.
func (m *CodingTestCaseMutation) Visible() (r bool, exists bool) {
	v := m.visible
	if v == nil {
		return
	}
	return *v, true
}

// OldVisible returns the old "visible" field's value of the CodingTestCase entity.
// If the CodingTestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodingTestCaseMutation) OldVisible(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVisible is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVisible requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisible: %w", err)
	}
	return oldValue.Visible, nil
}

// ResetVisible resets all changes to the "visible" field.
func (m *CodingTestCaseMutation) ResetVisible() {
	m.visible = nil
}

// SetCodingProblemID sets the "coding_problem" edge to the CodingProblem entity by id.
func (m *CodingTestCaseMutation) SetCodingProblemID(id int) {
	m.coding_problem = &id
}

// ClearCodingProblem clears the "coding_problem" edge to the CodingProblem entity.
func (m *CodingTestCaseMutation) ClearCodingProblem() {
	m.clearedcoding_problem = true
}

// CodingProblemCleared reports if the "coding_problem" edge to the CodingProblem entity was cleared.
func (m *CodingTestCaseMutation) CodingProblemCleared() bool {
	return m.clearedcoding_problem
}

// CodingProblemID returns the "coding_problem" edge ID in the mutation.
func (m *CodingTestCaseMutation) CodingProblemID() (id int, exists bool) {
	if m.coding_problem != nil {
		return *m.coding_problem, true
	}
	return
}

// CodingProblemIDs returns the "coding_problem" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CodingProblemID instead. It exists only for internal usage by the builders.
func (m *CodingTestCaseMutation) CodingProblemIDs() (ids []int) {
	if id := m.coding_problem; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCodingProblem resets all changes to the "coding_problem" edge.
func (m *CodingTestCaseMutation) ResetCodingProblem() {
	m.coding_problem = nil
	m.clearedcoding_problem = false
}

// Where appends a list predicates to the CodingTestCaseMutation builder.
func (m *CodingTestCaseMutation) Where(ps ...predicate.CodingTestCase) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CodingTestCaseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CodingTestCase).
func (m *CodingTestCaseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CodingTestCaseMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.input != nil {
		fields = append(fields, codingtestcase.FieldInput)
	}
	if m.output != nil {
		fields = append(fields, codingtestcase.FieldOutput)
	}
	if m.points != nil {
		fields = append(fields, codingtestcase.FieldPoints)
	}
	if m.visible != nil {
		fields = append(fields, codingtestcase.FieldVisible)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CodingTestCaseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case codingtestcase.FieldInput:
		return m.Input()
	case codingtestcase.FieldOutput:
		return m.Output()
	case codingtestcase.FieldPoints:
		return m.Points()
	case codingtestcase.FieldVisible:
		return m.Visible()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CodingTestCaseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case codingtestcase.FieldInput:
		return m.OldInput(ctx)
	case codingtestcase.FieldOutput:
		return m.OldOutput(ctx)
	case codingtestcase.FieldPoints:
		return m.OldPoints(ctx)
	case codingtestcase.FieldVisible:
		return m.OldVisible(ctx)
	}
	return nil, fmt.Errorf("unknown CodingTestCase field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CodingTestCaseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case codingtestcase.FieldInput:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInput(v)
		return nil
	case codingtestcase.FieldOutput:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutput(v)
		return nil
	case codingtestcase.FieldPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoints(v)
		return nil
	case codingtestcase.FieldVisible:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisible(v)
		return nil
	}
	return fmt.Errorf("unknown CodingTestCase field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CodingTestCaseMutation) AddedFields() []string {
	var fields []string
	if m.addpoints != nil {
		fields = append(fields, codingtestcase.FieldPoints)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CodingTestCaseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case codingtestcase.FieldPoints:
		return m.AddedPoints()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CodingTestCaseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case codingtestcase.FieldPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPoints(v)
		return nil
	}
	return fmt.Errorf("unknown CodingTestCase numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CodingTestCaseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CodingTestCaseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CodingTestCaseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CodingTestCase nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CodingTestCaseMutation) ResetField(name string) error {
	switch name {
	case codingtestcase.FieldInput:
		m.ResetInput()
		return nil
	case codingtestcase.FieldOutput:
		m.ResetOutput()
		return nil
	case codingtestcase.FieldPoints:
		m.ResetPoints()
		return nil
	case codingtestcase.FieldVisible:
		m.ResetVisible()
		return nil
	}
	return fmt.Errorf("unknown CodingTestCase field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CodingTestCaseMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.coding_problem != nil {
		edges = append(edges, codingtestcase.EdgeCodingProblem)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CodingTestCaseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case codingtestcase.EdgeCodingProblem:
		if id := m.coding_problem; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CodingTestCaseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CodingTestCaseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CodingTestCaseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcoding_problem {
		edges = append(edges, codingtestcase.EdgeCodingProblem)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CodingTestCaseMutation) EdgeCleared(name string) bool {
	switch name {
	case codingtestcase.EdgeCodingProblem:
		return m.clearedcoding_problem
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CodingTestCaseMutation) ClearEdge(name string) error {
	switch name {
	case codingtestcase.EdgeCodingProblem:
		m.ClearCodingProblem()
		return nil
	}
	return fmt.Errorf("unknown CodingTestCase unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CodingTestCaseMutation) ResetEdge(name string) error {
	switch name {
	case codingtestcase.EdgeCodingProblem:
		m.ResetCodingProblem()
		return nil
	}
	return fmt.Errorf("unknown CodingTestCase edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *int
	email         *string
	name          *string
	is_staff      *bool
	clearedFields map[string]struct{}
	drafts        map[int]struct{}
	removeddrafts map[int]struct{}
	cleareddrafts bool
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *UserMutation) ClearName() {
	m.name = nil
	m.clearedFields[user.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *UserMutation) NameCleared() bool {
	_, ok := m.clearedFields[user.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, user.FieldName)
}

// SetIsStaff sets the "is_staff" field.
func (m *UserMutation) SetIsStaff(b bool) {
	m.is_staff = &b
}

// IsStaff returns the value of the "is_staff" field in the mutation.
func (m *UserMutation) IsStaff() (r bool, exists bool) {
	v := m.is_staff
	if v == nil {
		return
	}
	return *v, true
}

// OldIsStaff returns the old "is_staff" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsStaff(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsStaff is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsStaff requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsStaff: %w", err)
	}
	return oldValue.IsStaff, nil
}

// ResetIsStaff resets all changes to the "is_staff" field.
func (m *UserMutation) ResetIsStaff() {
	m.is_staff = nil
}

// AddDraftIDs adds the "drafts" edge to the CodingDraft entity by ids.
func (m *UserMutation) AddDraftIDs(ids ...int) {
	if m.drafts == nil {
		m.drafts = make(map[int]struct{})
	}
	for i := range ids {
		m.drafts[ids[i]] = struct{}{}
	}
}

// ClearDrafts clears the "drafts" edge to the CodingDraft entity.
func (m *UserMutation) ClearDrafts() {
	m.cleareddrafts = true
}

// DraftsCleared reports if the "drafts" edge to the CodingDraft entity was cleared.
func (m *UserMutation) DraftsCleared() bool {
	return m.cleareddrafts
}

// RemoveDraftIDs removes the "drafts" edge to the CodingDraft entity by IDs.
func (m *UserMutation) RemoveDraftIDs(ids ...int) {
	if m.removeddrafts == nil {
		m.removeddrafts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.drafts, ids[i])
		m.removeddrafts[ids[i]] = struct{}{}
	}
}

// RemovedDrafts returns the removed IDs of the "drafts" edge to the CodingDraft entity.
func (m *UserMutation) RemovedDraftsIDs() (ids []int) {
	for id := range m.removeddrafts {
		ids = append(ids, id)
	}
	return
}

// DraftsIDs returns the "drafts" edge IDs in the mutation.
func (m *UserMutation) DraftsIDs() (ids []int) {
	for id := range m.drafts {
		ids = append(ids, id)
	}
	return
}

// ResetDrafts resets all changes to the "drafts" edge.
func (m *UserMutation) ResetDrafts() {
	m.drafts = nil
	m.cleareddrafts = false
	m.removeddrafts = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.is_staff != nil {
		fields = append(fields, user.FieldIsStaff)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmail:
		return m.Email()
	case user.FieldName:
		return m.Name()
	case user.FieldIsStaff:
		return m.IsStaff()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldIsStaff:
		return m.OldIsStaff(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldIsStaff:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsStaff(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldName) {
		fields = append(fields, user.FieldName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldIsStaff:
		m.ResetIsStaff()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.drafts != nil {
		edges = append(edges, user.EdgeDrafts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeDrafts:
		ids := make([]ent.Value, 0, len(m.drafts))
		for id := range m.drafts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddrafts != nil {
		edges = append(edges, user.EdgeDrafts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeDrafts:
		ids := make([]ent.Value, 0, len(m.removeddrafts))
		for id := range m.removeddrafts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddrafts {
		edges = append(edges, user.EdgeDrafts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeDrafts:
		return m.cleareddrafts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeDrafts:
		m.ResetDrafts()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
